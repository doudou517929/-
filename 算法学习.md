# 框架思维

## 和树相关的例子

```c++
// 求二叉树中最大路径和:后序遍历
/*路径 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点。路径和 是路径中各节点值的总和。*/
int ans = INT_MIN;
int oneSideMax(TreeNode* root) {
    if (root == nullptr) return 0;
    // 分别遍历左右子树。如果路径和为负数，抛弃之前的路径，从当前节点开始
    int left = max(0, oneSideMax(root->left));
    int right = max(0, oneSideMax(root->right));
    // 将左右子树与根节点连接起来拼成一条路径，和当前最大的结果做比较
    ans = max(ans, left + right + root->val);
    // 返回的是与根节点相连后左右子树分别的最大值
    return max(left, right) + root->val;
}
```

```java
// 根据前序遍历和中序遍历的结果还原一棵二叉树:前序遍历
TreeNode buildTree(int[] preorder, int preStart, int preEnd, int[] inorder, int inStart, int inEnd, Map<Integer, Integer> inMap) {
	// inMap<节点值，中序索引>
    if(preStart > preEnd || inStart > inEnd) return null;
	// 递归创建当前子树的根节点
    TreeNode root = new TreeNode(preorder[preStart]);
    // 取出中序中根节点的索引
    int inRoot = inMap.get(root.val);
    // 左子树中节点个数为中序中根节点的位置-初始节点的位置
    int numsLeft = inRoot - inStart;
	// 递归创建左右子树
    root.left = buildTree(preorder, preStart + 1, preStart + numsLeft, inorder, inStart, inRoot - 1, inMap);
    root.right = buildTree(preorder, preStart + numsLeft + 1, preEnd, inorder, inRoot + 1, inEnd, inMap);
    return root;
}
```

其实整个过程我们就多做一步：

1. 恢复一棵 BST二叉搜索树:中序遍历

   描述：给你二叉搜索树的根节点 root ，该树中的两个节点被错误地交换。请在不改变其结构的情况下，恢复这棵树。

   思路：
   	如果x无左孩子，则访问x的右孩子。
   	如果x有左孩子，则找到x左子树最右节点(左子树中序最后一个节点，x在中序中的前驱节点)predecessor
   		如果predecessor的右孩子空，将其右孩子指向x，然后访问x的左孩子
   		如果predecessor的右孩子不空，则此时其右孩子指向x，说明已经遍历完x的左子树，将predecessor的右孩子置空然后访问x的右孩子。
   	重复
   总结：
   	将当前节点左子树中最右边的节点指向它，这样在左子树遍历完成后我们通过这个指向走回了x，且能再通过这个知晓我们已经遍历完成了左子树，而不用再通过栈来维护，省去了栈的空间复杂度。

```c++
class Solution {
public:
    void recoverTree(TreeNode* root) {
        TreeNode *x = nullptr, *y = nullptr, *pred = nullptr, *predecessor = nullptr;
        while (root != nullptr) {
            if (root->left != nullptr) {
                // predecessor 节点就是当前 root 节点向左走一步，然后一直向右走至无法走为止，得到root左边的元素
                predecessor = root->left;
                while (predecessor->right != nullptr && predecessor->right != root) {
                    predecessor = predecessor->right;
                }
                // 让 predecessor 的右指针指向 root，继续遍历左子树。也就是把root左边的元素和root连起来。到时候可以一直向右遍历得到越来越大的节点。
                if (predecessor->right == nullptr) {
                    predecessor->right = root;
                    root = root->left;
                } else { // predecessor->right = root
                    // 左孩子为空说明左子树已经访问完了，我们需要断开链接
                    if (pred != nullptr && root->val < pred->val) {
                        // 如果前驱不空，比较根节点和前驱。更新之前保存的右边节点y，看看是否应该更往右
                        y = root;
                        if (x == nullptr) {
                            x = pred;
                        }
                    }
                    // 已经更换完或者不需要更换索引。开始遍历右子树。
                    pred = root; // pred保留当前节点的前驱
                    predecessor->right = nullptr; // 断开这个连接
                    root = root->right; // 继续遍历右子树
                }
            } else {
                // 如果没有左孩子，则直接访问右孩子
                if (pred != nullptr && root->val < pred->val) {
                    // 如果前驱不为空，比较根节点和前驱。正常前驱应该比根节点小，如果根节点小的话说明顺序错了
                    y = root; // y保存顺序错了的右边的小节点
                    if (x == nullptr) { // x如果空的话，保存前驱，也就是这个顺序不对的节点中较大的。
                        x = pred; // 如果x不空，说明已经存放了前驱，不用再存了，继续找
                    }
                }
                // 向右访问，保存当前根节点的前驱也就是上一个根节点
                pred = root;
                root = root->right;
            }
        }
        // 交换两个顺序错乱的节点
        swap(x->val, y->val);
    }
};
```

# 动态规划

## 技巧

求解动态规划的核心问题是穷举。需要「备忘录」或者「DP table」来优化穷举过程，避免不必要的计算。

**明确 base case -> 明确「状态」-> 明确「选择」 -> 定义 dp 数组/函数的含义**。

**出正确的状态转移方程**？

**例子**

1、**确定 base case**，这个很简单，显然目标金额 `amount` 为 0 时算法返回 0，因为不需要任何硬币就已经凑出目标金额了。

2、**确定「状态」，也就是原问题和子问题中会变化的变量**。由于硬币数量无限，硬币的面额也是题目给定的，只有目标金额会不断地向 base case 靠近，所以唯一的「状态」就是目标金额 `amount`。

3、**确定「选择」，也就是导致「状态」产生变化的行为**。目标金额为什么变化呢，因为你在选择硬币，你每选择一枚硬币，就相当于减少了目标金额。所以说所有硬币的面值，就是你的「选择」。

4、**明确** **`dp`** **函数/数组的定义**。我们这里讲的是自顶向下的解法，所以会有一个递归的 `dp` 函数，一般来说函数的参数就是状态转移中会变化的量，也就是上面说到的「状态」；函数的返回值就是题目要求我们计算的量。就本题来说，状态只有一个，即「目标金额」，题目要求我们计算凑出目标金额所需的最少硬币数量。所以我们可以这样定义 `dp` 函数：

`dp(n)` 的定义：输入一个目标金额 `n`，返回凑出目标金额 `n` 的最少硬币数量。

**`dp`** **数组的定义：当目标金额为** **`i`** **时，至少需要** **`dp[i]`** **枚硬币凑出**。

1. 零钱兑换

   描述：给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。

```c++
int coinChange(vector<int>& coins, int amount) {
    // 数组大小为 amount + 1，初始值也为 amount + 1
    vector<int> dp(amount + 1, amount + 1);
    // base case
    dp[0] = 0;
    // 外层 for 循环在遍历所有状态的所有取值
    for (int i = 0; i < dp.size(); i++) {
        // 内层 for 循环在求所有选择的最小值
        for (int coin : coins) {
            // 子问题无解，跳过
            if (i - coin < 0) continue;
            dp[i] = min(dp[i], 1 + dp[i - coin]);
        }
    }
    return (dp[amount] == amount + 1) ? -1 : dp[amount];
}
```

2. 目标和

   描述：给定一个非负整数数组，a1, a2, ..., an, 和一个目标数，S。现在你有两个符号 + 和 -。对于数组中的任意一个整数，你都可以从 + 或 -中选择一个符号添加在前面。

   返回可以使最终数组和为目标数 S 的所有添加符号的方法数。

   思路：

   ①回溯：O(2^N), 低效

       def backtrack(nums, i):
           if i == len(nums):
               if 达到 target:
                   result += 1
               return
           for op in { +1, -1 }:
               选择 op * nums[i]
               # 穷举 nums[i + 1] 的选择
               backtrack(nums, i + 1)
               撤销选择
   ```java
   int result = 0;
   
   /* 主函数 */
   int findTargetSumWays(int[] nums, int target) {
       if (nums.length == 0) return 0;
       backtrack(nums, 0, target);
       return result;
   }
   
   /* 回溯算法模板 */
   void backtrack(int[] nums, int i, int rest) {
       // base case
       if (i == nums.length) {
           if (rest == 0) {
               // 说明恰好凑出 target
               result++;
           }
           return;
       }
       // 给 nums[i] 选择 - 号
       rest += nums[i];
       // 穷举 nums[i + 1]
       backtrack(nums, i + 1, rest);
       // 撤销选择
       rest -= nums[i]; 
   
       // 给 nums[i] 选择 + 号
       rest -= nums[i];
       // 穷举 nums[i + 1]
       backtrack(nums, i + 1, rest);
       // 撤销选择
       rest += nums[i];
   }
   ```

   ②动态规划

   动态规划之所以比暴力算法快，是因为动态规划技巧消除了重叠子问题。

   如何发现重叠子问题？看是否可能出现重复的「状态」。对于递归函数来说，函数参数中会变的参数就是「状态」，对于 `backtrack` 函数来说，会变的参数为 `i` 和 `rest`。

   首先，如果我们把 `nums` 划分成两个子集 `A` 和 `B`，分别代表分配 `+` 的数和分配 `-` 的数，那么他们和 `target` 存在如下关系：

   ```
   sum(A) - sum(B) = target
   sum(A) = target + sum(B)
   sum(A) + sum(A) = target + sum(B) + sum(A)
   2 * sum(A) = target + sum(nums)
   ```

   综上，可以推出 `sum(A) = (target + sum(nums)) / 2`，也就是把原问题转化成：**`nums`** **中存在几个子集** **`A`**，使得 **`A`** **中元素的和为** **`(target + sum(nums)) / 2`**？

   ```java
   int findTargetSumWays(int[] nums, int target) {
       int sum = 0;
       for (int n : nums) sum += n;
       // 这两种情况，不可能存在合法的子集划分
       if (sum < target || (sum + target) % 2 == 1) {
           return 0;
       }
       return subsets(nums, (sum + target) / 2);
   }
   ```

   好的，变成背包问题的标准形式：

   **有一个背包，容量为** **`sum`**，现在给你 **`N`** **个物品，第** **`i`** **个物品的重量为** **`nums[i - 1]`**（注意 **`1 <= i <= N`**），每个物品只有一个，请问你有几种不同的方法能够恰好装满这个背包？

   现在，这就是一个正宗的动态规划问题了，下面按照我们一直强调的动态规划套路走流程：

   **第一步要明确两点，「状态」和「选择」**。

   对于背包问题，这个都是一样的，状态就是「背包的容量」和「可选择的物品」，选择就是「装进背包」或者「不装进背包」。

   **第二步要明确** **`dp`** **数组的定义**。

   按照背包问题的套路，可以给出如下定义：

   `dp[i][j] = x` 表示，若只在前 `i` 个物品中选择，若当前背包的容量为 `j`，则最多有 `x` 种方法可以恰好装满背包。

   翻译成我们探讨的子集问题就是，若只在 `nums` 的前 `i` 个元素中选择，若目标和为 `j`，则最多有 `x` 种方法划分子集。

   根据这个定义，显然 `dp[0][..] = 0`，因为没有物品的话，根本没办法装背包；`dp[..][0] = 1`，因为如果背包的最大载重为 0，「什么都不装」就是唯一的一种装法。

   我们所求的答案就是 `dp[N][sum]`，即使用所有 `N` 个物品，有几种方法可以装满容量为 `sum` 的背包。

   **第三步，根据「选择」，思考状态转移的逻辑**。

   回想刚才的 `dp` 数组含义，可以根据「选择」对 `dp[i][j]` 得到以下状态转移：

   如果不把 `nums[i]` 算入子集，**或者说你不把这第** **`i`** **个物品装入背包**，那么恰好装满背包的方法数就取决于上一个状态 `dp[i-1][j]`，继承之前的结果。

   如果把 `nums[i]` 算入子集，**或者说你把这第** **`i`** **个物品装入了背包**，那么只要看前 `i - 1` 个物品有几种方法可以装满 `j - nums[i-1]` 的重量就行了，所以取决于状态 `dp[i-1][j-nums[i-1]]`。

   PS：注意我们说的 `i` 是从 1 开始算的，而数组 `nums` 的索引时从 0 开始算的，所以 `nums[i-1]` 代表的是第 `i` 个物品的重量，`j - nums[i-1]` 就是背包装入物品 `i` 之后还剩下的容量。

   **由于** **`dp[i][j]`** **为装满背包的总方法数，所以应该以上两种选择的结果求和，得到状态转移方程**：

   `dp[i][j] = dp[i-1][j] + dp[i-1][j-nums[i-1]];`

   ```java
   /* 计算 nums 中有几个子集的和为 sum */
   int subsets(int[] nums, int sum) {
       int n = nums.length;
       //int[][] dp = new int[n + 1][sum + 1];
       int[] dp = new int[sum + 1];
       // base case
       //for (int i = 0; i <= n; i++) {
       //    dp[i][0] = 1;
       //}
       dp[0] = 1;
       for (int i = 1; i <= n; i++) {
           //for (int j = 0; j <= sum; j++) {
           for (int j = sum; j >= 0; j--) {
               if (j >= nums[i-1]) {
                   // 两种选择的结果之和
                  // dp[i][j] = dp[i-1][j] + dp[i-1][j-nums[i-1]];
                   dp[j] = dp[j] + dp[j-nums[i-1]];
               } else {
                   // 背包的空间不足，只能选择不装物品 i
                   //dp[i][j] = dp[i-1][j];
                   dp[j] = dp[j];
               }
           }
       }
       //return dp[n][sum];
       return dp[sum];
   }
   ```

   **对照二维** **`dp`**，只要把 **`dp`** **数组的第一个维度全都去掉就行了，唯一的区别就是这里的** **`j`** **要从后往前遍历，原因如下**：

   因为二维压缩到一维的根本原理是，`dp[j]` 和 `dp[j-nums[i-1]]` 还没被新结果覆盖的时候，相当于二维 `dp` 中的 `dp[i-1][j]` 和 `dp[i-1][j-nums[i-1]]`。

   那么，我们就要做到：**在计算新的** **`dp[j]`** **的时候，**`dp[j]` **和** **`dp[j-nums[i-1]]`** **还是上一轮外层 for 循环的结果**。

   如果你从前往后遍历一维 `dp` 数组，`dp[j]` 显然是没问题的，但是 `dp[j-nums[i-1]]` 已经不是上一轮外层 for 循环的结果了，这里就会使用错误的状态，当然得不到正确的答案。

## 状态压缩

能够使用状态压缩技巧的动态规划都是二维 `dp` 问题，**你看它的状态转移方程，如果计算状态** **`dp[i][j]`** **需要的都是** **`dp[i][j]`** **相邻的状态，那么就可以使用状态压缩技巧**，将二维的 `dp` 数组转化成一维，将空间复杂度从 O(N^2) 降低到 O(N)。

## 打家劫舍问题

1. 你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，**如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。**

   给定一个代表每个房屋存放金额的非负整数数组，计算你 **不触动警报装置的情况下** ，一夜之内能够偷窃到的最高金额。

   思路：**解决动态规划问题就是找「状态」和「选择」**

   假想你就是这个专业强盗，从左到右走过这一排房子，在每间房子前都有两种**选择**：抢或者不抢。

   如果你抢了这间房子，那么你肯定不能抢相邻的下一间房子了，只能从**下下间**房子开始做选择。

   如果你不抢这间房子，那么你可以走到**下一间**房子前，继续做选择。

   当你走过了最后一间房子后，你就没得抢了，能抢到的钱显然是 0（**base case**）。

   以上的逻辑很简单吧，其实已经明确了「状态」和「选择」：**你面前房子的索引就是状态，抢和不抢就是选择**。

   ![Image](pic\002.jpg)

   在两个选择中，每次都选更大的结果，最后得到的就是最多能抢到的 money：

   ```java
   // 自顶向下
   private int[] memo;
   // 主函数
   public int rob(int[] nums) {
       // 初始化备忘录
       memo = new int[nums.length];
       Arrays.fill(memo, -1);
       // 强盗从第 0 间房子开始抢劫
       return dp(nums, 0);
   }
   // 返回 nums[start..] 能抢到的最大值
   private int dp(int[] nums, int start) {
       if (start >= nums.length) {
           return 0;
       }
   	// 对于同一start位置，存在重叠子问题->用备忘录进行优化
       // 避免重复计算
       if (memo[start] != -1) return memo[start];
   	// 不抢，去下家; 抢，去下下家
       int res = Math.max(dp(nums, start + 1), 
                       nums[start] + dp(nums, start + 2));
       // 记入备忘录
       memo[start] = res;
       return res;
   }
   
   // 自底向上：状态转移只和dp[i]最近的两个状态有关，所以可以进一步优化，将空间复杂度降低到 O(1)。
   int rob(int[] nums) {
       int n = nums.length;
       // dp[i] = x 表示：
       // 从第 i 间房子开始抢劫，最多能抢到的钱为 x
       // base case: dp[n] = 0
       // 记录 dp[i+1] 和 dp[i+2]
       int dp_i_1 = 0, dp_i_2 = 0;
       // 记录 dp[i]
       int dp_i = 0; 
       for (int i = n - 1; i >= 0; i--) {
           // 当前家不抢，收益和在下一家时一样。抢了当前家，收益为当前家和下下家累计
        dp_i = Math.max(dp_i_1, nums[i] + dp_i_2);
           // i前移，下下家变成了上一次的下家
           dp_i_2 = dp_i_1;
           // 下家变成了刚更新的当前家
           dp_i_1 = dp_i;
       }
       return dp_i;
   }
   ```
   
2. **这些房子不是一排，而是围成了一个圈**。

   也就是说，现在第一间房子和最后一间房子也相当于是相邻的，不能同时抢。

   首先，首尾房间不能同时被抢，那么只可能有三种不同情况：要么都不被抢；要么第一间房子被抢最后一间不抢；要么最后一间房子被抢第一间不抢。

   **只要比较情况二和情况三就行了，因为这两种情况对于房子的选择余地比情况一大呀，房子里的钱数都是非负数，所以选择余地大，最优决策结果肯定不会小**。

   ```java
   public int rob(int[] nums) {
       int n = nums.length;
       if (n == 1) return nums[0];
       // 第一间房子被抢最后一间不抢；最后一间房子被抢第一间不抢。
       return Math.max(robRange(nums, 0, n - 2), 
                       robRange(nums, 1, n - 1));
   }
   
   // 仅计算闭区间 [start,end] 的最优结果
   int robRange(int[] nums, int start, int end) {
       int n = nums.length;
       int dp_i_1 = 0, dp_i_2 = 0;
       int dp_i = 0;
       for (int i = end; i >= start; i--) {
           dp_i = Math.max(dp_i_1, nums[i] + dp_i_2);
           dp_i_2 = dp_i_1;
           dp_i_1 = dp_i;
       }
       return dp_i;
   }
   ```

3. 第三题又想法设法地变花样了，此强盗发现现在面对的房子不是一排，不是一圈，而是一棵二叉树！房子在二叉树的节点上，相连的两个房子不能同时被抢劫

   ```java
   int rob(TreeNode root) {
       int[] res = dp(root);
       return Math.max(res[0], res[1]);
   }
   
   /* 返回一个大小为 2 的数组 arr
   arr[0] 表示不抢 root 的话，得到的最大钱数
   arr[1] 表示抢 root 的话，得到的最大钱数 */
   int[] dp(TreeNode root) {
       if (root == null)
           return new int[]{0, 0};
       int[] left = dp(root.left);
       int[] right = dp(root.right);
       // 抢，下家就不能抢了
       int rob = root.val + left[0] + right[0];
       // 不抢，下家可抢可不抢，取决于收益大小
       int not_rob = Math.max(left[0], left[1])
                   + Math.max(right[0], right[1]);
   
       return new int[]{not_rob, rob};
   }
   ```

## 背包问题

- 0-1背包

  给你一个可装载重量为`W`的背包和`N`个物品，每个物品有重量和价值两个属性。其中第`i`个物品的重量为`wt[i]`，价值为`val[i]`，现在让你用这个背包装物品，最多能装的价值是多少？

  **第一步要明确两点，「状态」和「选择」**。

  状态有两个，就是「背包的容量」和「可选择的物品」

  选择就是「装进背包」或者「不装进背包」

  ```
  for 状态1 in 状态1的所有取值：
      for 状态2 in 状态2的所有取值：
          for ...
              dp[状态1][状态2][...] = 择优(选择1，选择2...)
  ```

  **第二步要明确`dp`数组的定义**。

  `dp[i][w]`的定义如下：对于前`i`个物品，当前背包的容量为`w`，这种情况下可以装的最大价值是`dp[i][w]`。

  ```
  int dp[N+1][W+1]
  dp[0][..] = 0
  dp[..][0] = 0
  
  for i in [1..N]:
      for w in [1..W]:
          dp[i][w] = max(
              把物品 i 装进背包,
              不把物品 i 装进背包
          )
  return dp[N][W]
  ```

  **第三步，根据「选择」，思考状态转移的逻辑**。

  ```
  for i in [1..N]:
      for w in [1..W]:
          dp[i][w] = max(
              dp[i-1][w],
              dp[i-1][w - wt[i-1]] + val[i-1]
          )
  return dp[N][W]
  ```

  答案

  ```c++
  int knapsack(int W, int N, vector<int>& wt, vector<int>& val) {
      // vector 全填入 0，base case 已初始化
      vector<vector<int>> dp(N + 1, vector<int>(W + 1, 0));
      for (int i = 1; i <= N; i++) {
          for (int w = 1; w <= W; w++) {
              if (w - wt[i-1] < 0) {
                  // 当前背包容量装不下，只能选择不装入背包
                  dp[i][w] = dp[i - 1][w];
              } else {
                  // 装入或者不装入背包，择优
                  dp[i][w] = max(dp[i - 1][w - wt[i-1]] + val[i-1], 
                                 dp[i - 1][w]);
              }
          }
      }
  
      return dp[N][W];
  }
  ```

- 子集背包问题

1. 分割等和子集

   给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。

   注意:

   每个数组中的元素不会超过 100
   数组的大小不会超过 200

   思路：`dp[i][j] = x` 表示，对于前 `i` 个物品，当前背包的容量为 `j` 时，若 `x` 为 `true`，则说明可以恰好将背包装满，若 `x` 为 `false`，则说明不能恰好将背包装满。根据这个定义，我们想求的最终答案就是 `dp[N][sum/2]`，base case 就是 `dp[..][0] = true` 和 `dp[0][..] = false`，因为背包没有空间的时候，就相当于装满了，而当没有物品可选择的时候，肯定没办法装满背包。

   **唯一需要注意的是** **`j`** **应该从后往前反向遍历，因为每个物品（或者说数字）只能用一次，以免之前的结果影响其他的结果**。

   时间复杂度 O(n*sum)，空间复杂度 O(sum)

   ```c++
   bool canPartition(vector<int>& nums) {
       int sum = 0, n = nums.size();
       for (int num : nums) sum += num;
       // 和为奇数时，不可能划分成两个和相等的集合
       if (sum % 2 != 0) return false;
       sum = sum / 2;
       vector<bool> dp(sum + 1, false);
       // base case
       dp[0] = true;
   
       for (int i = 0; i < n; i++) 
           for (int j = sum; j >= 0; j--) 
               // 背包容量不足，不能装入第 i 个物品-跳过
               // 装入或不装入背包
               if (j - nums[i] >= 0) 
                   dp[j] = dp[j] || dp[j - nums[i]];
   
       return dp[sum];
   }
   ```

- 完全背包问题

  1. 零钱兑换2

     描述：给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。 

     思路：

     ```
     状态+选择：
     	状态：背包容量，可选择的物品
     	选择：装包，不装
     	for 状态1 in 状态1的所有取值：
             for 状态2 in 状态2的所有取值：
                 for ...
                     dp[状态1][状态2][...] = 计算(选择1，选择2...)
     明确dp数组定义：
     	若只使用coins中的前i个硬币的面值，想凑出金额j，有dp[i][j]中凑法。
     根据选择，思考状态转移逻辑：
     	第i个物品不装包：dp[i][j] = dp[i - 1][j]
     	第i个物品装包：dp[i][j] = dp[i][j - coins[i - 1]]
     ```

     ```java
     int change(int amount, int[] coins) {
         int n = coins.length;
         int[][] dp = amount int[n + 1][amount + 1];
         // base case：面值为0时，对每个硬币有一种方法
         for (int i = 0; i <= n; i++) 
             dp[i][0] = 1;
     
         for (int i = 1; i <= n; i++) {
             for (int j = 1; j <= amount; j++)
                 // 目标值比第i个硬币面值大：i装包和不装包。i-1表示第i个硬币
                 if (j - coins[i-1] >= 0)
                     dp[i][j] = dp[i - 1][j] 
                              + dp[i][j - coins[i-1]];
                 else 
                     // 否则只有不装包
                     dp[i][j] = dp[i - 1][j];
         }
         return dp[n][amount];
     }
     // 改进：压缩空间
     int change(int amount, int[] coins) {
         int n = coins.length;
         int[] dp = new int[amount + 1];
         dp[0] = 1; // base case
         for (int i = 0; i < n; i++)
             for (int j = 1; j <= amount; j++)
                 if (j - coins[i] >= 0)
                     dp[j] = dp[j] + dp[j-coins[i]];
     
         return dp[amount];
     }
     ```

     

## 子序列

**模板**

```
第一种思路：一维dp数组
在arr[0~i]中以arr[i]结尾的目标子序列长度是dp[i]
int n = array.length;
int[] dp = new int[n];

for (int i = 1; i < n; i++) {
    for (int j = 0; j < i; j++) {
        dp[i] = 最值(dp[i], dp[j] + ...)
    }
}

第二种思路：二维dp数组
int n = arr.length;
int[][] dp = new dp[n][n];

for (int i = 0; i < n; i++) {
    for (int j = 1; j < n; j++) {
        if (arr[i] == arr[j]) 
            dp[i][j] = dp[i][j] + ...
        else
            dp[i][j] = 最值(...)
    }
}
①涉及两个字符串/数组：在子数组arr1[0..i]和子数组arr2[0..j]中，我们要求的子序列（最长公共子序列）长度为dp[i][j]
②只涉及一个字符串/数组：在子数组array[i..j]中，我们要求的子序列（最长回文子序列）的长度为dp[i][j]
```

1. 编辑距离

   描述：给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。

   你可以对一个单词进行如下三种操作：

   插入一个字符
   删除一个字符
   替换一个字符

   思路：

   ```
   base case是i走完s1或j走完s2
   if s1[i] == s2[j]:
       啥都别做（skip）
       i, j 同时向前移动
   else:
       三选一：
           插入（insert）
           删除（delete）
           替换（replace）
   ```

   ```python
   def minDistance(s1, s2) -> int:
   	memo = dict() # 备忘录
       def dp(i, j):
           # 备忘录改进
           if (i, j) in memo:
               return memo[(i, j)]
           # base case
           if i == -1: return j + 1
           if j == -1: return i + 1
   
           if s1[i] == s2[j]:
               # dp(i, j) == dp(i - 1, j - 1)
               return dp(i - 1, j - 1)  # 啥都不做
           	# 备忘录改进：memo[(i, j)] = ...
           else:
               return min(
                   dp(i, j - 1) + 1,    # s[i]插入s2[j]
                   dp(i - 1, j) + 1,    # 删除s1[i]
                   dp(i - 1, j - 1) + 1 # s1[i]替换为s2[j]
               )
           	# 备忘录改进: memo[(i, j)] = ...
           # 备忘录改进：return memo[(i, j)]
   
       # i，j 初始化指向最后一个索引
       return dp(len(s1) - 1, len(s2) - 1)
   ```

   ```java
   int minDistance(String s1, String s2) {
       int m = s1.length(), n = s2.length();
       int[][] dp = new int[m + 1][n + 1];
       // base case 
       for (int i = 1; i <= m; i++)
           dp[i][0] = i;
       for (int j = 1; j <= n; j++)
           dp[0][j] = j;
       // 自底向上求解
       for (int i = 1; i <= m; i++)
           for (int j = 1; j <= n; j++)
               if (s1.charAt(i-1) == s2.charAt(j-1))
                   dp[i][j] = dp[i - 1][j - 1];
               else               
                   dp[i][j] = min(
                       dp[i - 1][j] + 1,
                       dp[i][j - 1] + 1,
                       dp[i-1][j-1] + 1
                   );
       // 储存着整个 s1 和 s2 的最小编辑距离
       return dp[m][n];
   }
   
   int min(int a, int b, int c) {
       return Math.min(a, Math.min(b, c));
   }
   ```

2. 最长递增子序列

   思路：d[i] = 以nums[i]结尾的最长递增子序列的长度。所以res=dp[0~n]中最大的元素

   更新：如果nums[5]=3,那么找到前面结尾比3小的数字，把3接到最后可以形成新的递增子序列，这个子序列长度+1.`if (nums[i] > nums[j]) dp[i] =Math.max(dp[i], dp[j] + 1)`, j=0~i.

   ```java
   public int lengthOfLIS(int[] nums) {
       int[] dp = new int[nums.length];
       // base case：dp 数组全都初始化为 1
       Arrays.fill(dp, 1);
       for (int i = 0; i < nums.length; i++) {
           for (int j = 0; j < i; j++) {
               if (nums[i] > nums[j]) 
                   dp[i] = Math.max(dp[i], dp[j] + 1);
           }
       }
   
       int res = 0;
       for (int i = 0; i < dp.length; i++) {
           res = Math.max(res, dp[i]);
       }
       return res;
   }
   // 二分查找思想：把点数小的纸牌压在点数大的上，分成若干堆。遇到多个可选择堆要放在最左边的堆
   public int lengthOfLIS(int[] nums) {
       int[] top = new int[nums.length];
       // 牌堆数初始化为 0
       int piles = 0;
       for (int i = 0; i < nums.length; i++) {
           // 要处理的扑克牌
           int poker = nums[i];
   
           /***** 搜索左侧边界的二分查找 *****/
           int left = 0, right = piles;
           while (left < right) {
               int mid = (left + right) / 2;
               if (top[mid] > poker) {
                   right = mid;
               } else if (top[mid] < poker) {
                   left = mid + 1;
               } else {
                   right = mid;
               }
           }
           /*********************************/
   
           // 没找到合适的牌堆，新建一堆
           if (left == piles) piles++;
           // 把这张牌放到牌堆顶
           top[left] = poker;
       }
       // 牌堆数就是 LIS 长度
       return piles;
   }
   ```

3. 俄罗斯套娃信封问题

   描述：给你一个二维整数数组 envelopes ，其中 envelopes[i] = [wi, hi] ，表示第 i 个信封的宽度和高度。

   当另一个信封的宽度和高度都比这个信封大的时候，这个信封就可以放进另一个信封里，如同俄罗斯套娃一样。

   请计算 最多能有多少个 信封能组成一组“俄罗斯套娃”信封（即可以把一个信封放到另一个信封里面）。

   注意：不允许旋转信封。

   思路：最长递增子序列的变种。先对宽度升序，宽度相同按高度降序。宽度相同的数对中最多选一个。

   ```java
   // envelopes = [[w, h], [w, h]...]
   public int maxEnvelopes(int[][] envelopes) {
       int n = envelopes.length;
       // 按宽度升序排列，如果宽度一样，则按高度降序排列
       Arrays.sort(envelopes, new Comparator<int[]>() 
       {
           public int compare(int[] a, int[] b) {
               return a[0] == b[0] ? 
                   b[1] - a[1] : a[0] - b[0];
           }
       });
       // 对高度数组寻找 LIS
       int[] height = new int[n];
       for (int i = 0; i < n; i++)
           height[i] = envelopes[i][1];
   
       return lengthOfLIS(height);
   }
   /* 返回 nums 中 LIS 的长度 */
   public int lengthOfLIS(int[] nums) {
       int piles = 0, n = nums.length;
       int[] top = new int[n];
       for (int i = 0; i < n; i++) {
           // 要处理的扑克牌
           int poker = nums[i];
           int left = 0, right = piles;
           // 二分查找插入位置
           while (left < right) {
               int mid = (left + right) / 2;
               if (top[mid] >= poker)
                   right = mid;
               else
                   left = mid + 1;
           }
           // 如果left=piles说明找到了一个合适的插入点，更新堆顶和长度。否则说明left比当前nums[left]小，只更新堆中那个比nums[i]大的元素, 换成比nums[left]更小的nums[i]。
           if (left == piles) piles++;
           // 把这张牌放到牌堆顶
           top[left] = poker;
       }
       // 牌堆数就是 LIS 长度
       return piles;
   }
   ```

4. 最大子序和

   思路：数组中有负数，不能用滑动窗口。动态规划：以nums[i]结尾的最大子数组和为dp[i]。更新dp[i]的方法：要么自成一派，要么和前面的子数组合并`dp[i] = Math.max(nums[i], nums[i] + dp[i - 1]);`

   ```java
   int maxSubArray(int[] nums) {
       int n = nums.length;
       if (n == 0) return 0;
       // base case
       int dp_0 = nums[0];
       int dp_1 = 0, res = dp_0;
   
       for (int i = 1; i < n; i++) {
           // dp[i] = max(nums[i], nums[i] + dp[i-1])
           dp_1 = Math.max(nums[i], nums[i] + dp_0);
           dp_0 = dp_1;
           // 顺便计算最大的结果
           res = Math.max(res, dp_1);
       }
   
       return res;
   }
   ```

5. 最长公共子序列

   描述：给定两个字符串 text1 和 text2，返回这两个字符串的最长 公共子序列 的长度。如果不存在 公共子序列 ，返回 0 。

   一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。

   例如，"ace" 是 "abcde" 的子序列，但 "aec" 不是 "abcde" 的子序列。
   两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。

   思路：

   ```
   动态规划
   dp(s2, i, s2, j)=maxlen(s1[i...], s2[j...])
   答案为dp(s1, 0, s2, 0). 
   起始i = len(s1), j = len(s2)
   if s1[i] == s2[j]: 更新长度为1 + dp(s1, i + 1, s2, j + 1)
   else: 三种情况取最大值
   	①s1[i]不在lcs中：dp(s1, i + 1, s2, j)
   	②s2[j]不在lcs中：dp(s1, i, s2, j + 1)
   	③都不在lcs中：dp(s1, i + 1, s2, j + 1),可以直接忽略，因为已经包含在前两个里
   ```

   ```java
   // 备忘录，消除重叠子问题
   int[][] memo;
   
   /* 主函数 自顶向下*/
   int longestCommonSubsequence(String s1, String s2) {
       int m = s1.length(), n = s2.length();
       // 备忘录值为 -1 代表未曾计算
       memo = new int[m][n];
       for (int[] row : memo) 
           Arrays.fill(row, -1);
       // 计算 s1[0..] 和 s2[0..] 的 lcs 长度
       return dp(s1, 0, s2, 0);
   }
   
   // 定义：计算 s1[i..] 和 s2[j..] 的最长公共子序列长度
   int dp(String s1, int i, String s2, int j) {
       // base case
       if (i == s1.length() || j == s2.length()) {
           return 0;
       }
       // 如果之前计算过，则直接返回备忘录中的答案
       if (memo[i][j] != -1) {
           return memo[i][j];
       }
       // 根据 s1[i] 和 s2[j] 的情况做选择
       if (s1.charAt(i) == s2.charAt(j)) {
           // s1[i] 和 s2[j] 必然在 lcs 中
           memo[i][j] = 1 + dp(s1, i + 1, s2, j + 1);
       } else {
           // s1[i] 和 s2[j] 至少有一个不在 lcs 中
           memo[i][j] = Math.max(
               dp(s1, i + 1, s2, j),
               dp(s1, i, s2, j + 1)
           );
       }
       return memo[i][j];
   }
   // 自底向上
   int longestCommonSubsequence(String s1, String s2) {
       int m = s1.length(), n = s2.length();
       int[][] dp = new int[m + 1][n + 1];
       // 定义：s1[0..i-1] 和 s2[0..j-1] 的 lcs 长度为 dp[i][j]
       // 目标：s1[0..m-1] 和 s2[0..n-1] 的 lcs 长度，即 dp[m][n]
       // base case: dp[0][..] = dp[..][0] = 0
   
       for (int i = 1; i <= m; i++) {
           for (int j = 1; j <= n; j++) {
               // 现在 i 和 j 从 1 开始，所以要减一
               if (s1.charAt(i - 1) == s2.charAt(j - 1)) {
                   // s1[i-1] 和 s2[j-1] 必然在 lcs 中
                   dp[i][j] = 1 + dp[i - 1][j - 1];
               } else {
                   // s1[i-1] 和 s2[j-1] 至少有一个不在 lcs 中
                   dp[i][j] = Math.max(dp[i][j - 1], dp[i - 1][j]);
               }
           }
       }
   
       return dp[m][n];
   }
   ```

6. 两个字符串的删除操作

   描述：给定两个单词 *word1* 和 *word2*，找到使得 *word1* 和 *word2* 相同所需的最小步数，每步可以删除任意一个字符串中的一个字符。

   思路：删除的结果是它俩的最长公共子序列

   ```
   int minDistance(String s1, String s2) {
       int m = s1.length(), n = s2.length();
       // 复用前文计算 lcs 长度的函数
       int lcs = longestCommonSubsequence(s1, s2);
       return m - lcs + n - lcs;
   }
   int longestCommonSubsequence(String s1, String s2) {
       int m = s1.length(), n = s2.length();
       int[][] dp = new int[m + 1][n + 1];
       // 定义：s1[0..i-1] 和 s2[0..j-1] 的 lcs 长度为 dp[i][j]
       // 目标：s1[0..m-1] 和 s2[0..n-1] 的 lcs 长度，即 dp[m][n]
       // base case: dp[0][..] = dp[..][0] = 0
   
       for (int i = 1; i <= m; i++) {
           for (int j = 1; j <= n; j++) {
               // 现在 i 和 j 从 1 开始，所以要减一
               if (s1.charAt(i - 1) == s2.charAt(j - 1)) {
                   // s1[i-1] 和 s2[j-1] 必然在 lcs 中
                   dp[i][j] = 1 + dp[i - 1][j - 1];
               } else {
                   // s1[i-1] 和 s2[j-1] 至少有一个不在 lcs 中
                   dp[i][j] = Math.max(dp[i][j - 1], dp[i - 1][j]);
               }
           }
       }
   
       return dp[m][n];
   }
   ```

7. 两个字符串的最小ASCII和

   ```java
   // 备忘录
   int memo[][];
   /* 主函数 */    
   int minimumDeleteSum(String s1, String s2) {
       int m = s1.length(), n = s2.length();
       // 备忘录值为 -1 代表未曾计算
       memo = new int[m][n];
       for (int[] row : memo) 
           Arrays.fill(row, -1);
   
       return dp(s1, 0, s2, 0);
   }
   
   // 定义：将 s1[i..] 和 s2[j..] 删除成相同字符串，
   // 最小的 ASCII 码之和为 dp(s1, i, s2, j)。
   int dp(String s1, int i, String s2, int j) {
       int res = 0;
       // base case
       if (i == s1.length()) {
           // 如果 s1 到头了，那么 s2 剩下的都得删除
           for (; j < s2.length(); j++)
               res += s2.charAt(j);
           return res;
       }
       if (j == s2.length()) {
           // 如果 s2 到头了，那么 s1 剩下的都得删除
           for (; i < s1.length(); i++)
               res += s1.charAt(i);
           return res;
       }
   
       if (memo[i][j] != -1) {
           return memo[i][j];
       }
   
       if (s1.charAt(i) == s2.charAt(j)) {
           // s1[i] 和 s2[j] 都是在 lcs 中的，不用删除
           memo[i][j] = dp(s1, i + 1, s2, j + 1);
       } else {
           // s1[i] 和 s2[j] 至少有一个不在 lcs 中，删一个
           memo[i][j] = Math.min(
               s1.charAt(i) + dp(s1, i + 1, s2, j),
               s2.charAt(j) + dp(s1, i, s2, j + 1)
           );
       }
       return memo[i][j];
   }
   // 另一种解法
   class Solution {
       public int minimumDeleteSum(String s1, String s2) {
           int[][] dp = new int[s1.length() + 1][s2.length() + 1];
   		// 初始化最后一行和最后一列为，就是有一个到头，另一个剩余字符累加，所以从后往前
           for (int i = s1.length() - 1; i >= 0; i--) {
               dp[i][s2.length()] = dp[i+1][s2.length()] + s1.codePointAt(i);
           }
           for (int j = s2.length() - 1; j >= 0; j--) {
               dp[s1.length()][j] = dp[s1.length()][j+1] + s2.codePointAt(j);
           }
           // 从尾到头遍历
           for (int i = s1.length() - 1; i >= 0; i--) {
               for (int j = s2.length() - 1; j >= 0; j--) {
                   if (s1.charAt(i) == s2.charAt(j)) {
                       dp[i][j] = dp[i+1][j+1];
                   } else {
                       dp[i][j] = Math.min(dp[i+1][j] + s1.codePointAt(i),
                                           dp[i][j+1] + s2.codePointAt(j));
                   }
               }
           }
           return dp[0][0];
       }
   }
   ```

8. 最长回文子串

   思路：在子串`s[i..j]`中，最长回文子序列的长度为`dp[i][j]`。

   ```
   如果s[i] == s[j], 它俩加上s[i+1~j-1]中的最长回文子串就是s[i~j]的最长回文子串。
   	dp[i][j] = dp[i + 1][j - 1] + 2;
   如果s[i] != s[j], 分别加入s[i+1~j-1], 看哪个子串产生你的回文子序列更长
   	dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]);
   ```

   ```c++
   int longestPalindromeSubseq(string s) {
       int n = s.size();
       // dp 数组全部初始化为 0
       vector<vector<int>> dp(n, vector<int>(n, 0));
       // base case
       for (int i = 0; i < n; i++)
           dp[i][i] = 1;
       // 反着遍历保证正确的状态转移
       for (int i = n - 1; i >= 0; i--) {
           for (int j = i + 1; j < n; j++) {
               // 状态转移方程
               if (s[i] == s[j])
                   dp[i][j] = dp[i + 1][j - 1] + 2;
               else
                   dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]);
           }
       }
       // 整个 s 的最长回文子串长度
       return dp[0][n - 1];
   }
   ```

   

# 回溯

## 技巧

    def backtrack(路径, 选择列表):
        if 满足结束条件:
            result.add(路径)
            return
        for 选择 in 选择列表:
            做选择
            backtrack(路径, 选择列表)
            撤销选择
**解决一个回溯问题，实际上就是一个决策树的遍历过程**。

你只需要思考 3 个问题：

1、路径：也就是已经做出的选择。

2、选择列表：也就是你当前可以做的选择。

3、结束条件：也就是到达决策树底层，无法再做选择的条件。

1. 全排列

   描述：给定一个 没有重复 数字的序列，返回其所有可能的全排列。

```java
List<List<Integer>> res = new LinkedList<>();

/* 主函数，输入一组不重复的数字，返回它们的全排列 */
List<List<Integer>> permute(int[] nums) {
    // 记录「路径」
    LinkedList<Integer> track = new LinkedList<>();
    backtrack(nums, track);
    return res;
}

// 路径：记录在 track 中
// 选择列表：nums 中不存在于 track 的那些元素
// 结束条件：nums 中的元素全都在 track 中出现
void backtrack(int[] nums, LinkedList<Integer> track) {
    // 触发结束条件
    if (track.size() == nums.length) {
        res.add(new LinkedList(track));
        return;
    }

    for (int i = 0; i < nums.length; i++) {
        // 排除不合法的选择
        if (track.contains(nums[i]))
            continue;
        // 做选择
        track.add(nums[i]);
        // 进入下一层决策树
        backtrack(nums, track);
        // 取消选择
        track.removeLast();
    }
}
```

2. 递增子序列

   ```c++
   class Solution {
       vector<vector<int>> res;
       vector<int> vec;
       void findZi(vector<int>& nums, int index, int last) {
           if (index == nums.size()) {
               if (vec.size() >= 2) {
                   res.push_back(vec);
               }
               return;
           }
           if (nums[index] >= last) {
               vec.push_back(nums[index]);
           
               findZi(nums, index + 1, nums[index]);
               vec.pop_back();
           }
           if (nums[index] != last) {
               findZi(nums, index + 1, last);
           }
           
           
           
       }
   public:
       vector<vector<int>> findSubsequences(vector<int>& nums) {
           findZi(nums, 0, INT_MIN);
           return res;
       }
   };
   ```
   
3. n 皇后问题

   研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。皇后可以攻击同一行、同一列、左上左下右上右下四个方向的任意单位。

   给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案。

   每一种解法包含一个不同的 n 皇后问题 的棋子放置方案，该方案中 'Q' 和 '.' 分别代表了皇后和空位。

```c++
// N 皇后问题
// 函数找到一个答案后就返回 true
// 路径：board 中小于 row 的那些行都已经成功放置了皇后
// 选择列表：第 row 行的所有列都是放置皇后的选择
// 结束条件：row 超过 board 的最后一行
/* 是否可以在 board[row][col] 放置皇后？ */
bool isValid(vector<string>& board, int row, int col) {
    int n = board.size();
    // 检查列是否有皇后互相冲突
    for (int i = 0; i < n; i++) {
        if (board[i][col] == 'Q')
            return false;
    }
    // 检查右上方是否有皇后互相冲突
    for (int i = row - 1, j = col + 1; i >= 0 && j < n; i--, j++) {
        if (board[i][j] == 'Q')
            return false;
    }
    // 检查左上方是否有皇后互相冲突
    for (int i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--) {
        if (board[i][j] == 'Q')
            return false;
    }
    return true;
}
bool backtrack(vector<string>& board, int row) {
    // 触发结束条件
    if (row == board.size()) {
        res.push_back(board);
        return true;
    }

    int n = board[row].size();
    for (int col = 0; col < n; col++) {
        // 排除不合法选择
        if (!isValid(board, row, col)) 
            continue;
        // 做选择
        board[row][col] = 'Q';
        // 进入下一行决策
        backtrack(board, row + 1);
        // 撤销选择
        board[row][col] = '.';
    }
    return false;
}
vector<vector<string>> solveNQueens(int n) {
    vector<string> board(n, string(n, '.'));
    backtrack(board, 0);
    return res;
}
```

# BFS

## 技巧

BFS 相对 DFS 的最主要的区别是：**BFS 找到的路径一定是最短的，但代价就是空间复杂度比 DFS 大很多**

**问题的本质就是让你在一幅「图」中找到从起点** **`start`** **到终点** **`target`** **的最近距离**

**和DFS比较**

DFS 实际上是靠递归的堆栈记录走过的路径，要找到最短路径，肯定得把二叉树中所有树杈都探索完才能对比出最短的路径有多长。而 BFS 借助队列做到一次一步「齐头并进」，是可以在不遍历完整棵树的条件下找到最短距离的。

形象点说，DFS 是线，BFS 是面；DFS 是单打独斗，BFS 是集体行动。这个应该比较容易理解吧。

BFS 可以找到最短距离，但是空间复杂度高，而 DFS 的空间复杂度较低。

假设给你的这个二叉树是满二叉树，节点数为 `N`，对于 DFS 算法来说，空间复杂度无非就是递归堆栈，最坏情况下顶多就是树的高度，也就是 `O(logN)`。对于BFS 算法，队列中每次都会储存着二叉树一层的节点，这样的话最坏情况下空间复杂度应该是树的最底层节点的数量，也就是 `N/2`，用 Big O 表示的话也就是 `O(N)`。

由此观之，BFS 还是有代价的，一般来说在找最短路径的时候使用 BFS，其他时候还是 DFS 使用得多一些（主要是递归代码好写）。

**二叉树的最小高度**

```c++
int minDepth(TreeNode* root) {
        if (root == nullptr) {
            return 0;
        }
        int depth = 1;
        queue<TreeNode*> q;
        q.push(root);
        while (!q.empty()) {
            int n = q.size();
            /* 将当前队列中的所有节点向四周扩散 */
            for (int i = 0; i < n; ++i) {
                TreeNode* tmp = q.front();
                q.pop();
                /* 判断是否到达终点 */
                if (tmp->left == nullptr && tmp->right == nullptr) {
                    return depth;
                }
                /* 将 cur 的相邻节点加入队列 */
                if (tmp->left != nullptr) {
                    q.push(tmp->left);
                }
                if (tmp->right != nullptr) {
                    q.push(tmp->right);
                }
            }
            /* 这里增加步数 */
            ++depth;
        }
        return depth;
    }
```

**解开密码锁的最少次数**

你有一个带有四个圆形拨轮的转盘锁。每个拨轮都有10个数字： '0', '1', '2', '3', '4', '5', '6', '7', '8', '9' 。每个拨轮可以自由旋转：例如把 '9' 变为  '0'，'0' 变为 '9' 。每次旋转都只能旋转一个拨轮的一位数字。

锁的初始数字为 '0000' ，一个代表四个拨轮的数字的字符串。

列表 deadends 包含了一组死亡数字，一旦拨轮的数字和列表里的任何一个元素相同，这个锁将会被永久锁定，无法再被旋转。

字符串 target 代表可以解锁的数字，你需要给出最小的旋转次数，如果无论如何不能解锁，返回 -1。

**双向 BFS 优化**：**传统的 BFS 框架就是从起点开始向四周扩散，遇到终点时停止；而双向 BFS 则是从起点和终点同时开始扩散，当两边有交集的时候停止**。**不过，双向 BFS 也有局限，因为你必须知道终点在哪里**。

```c++
class Solution {
    // 将 s[j] 向上拨动一次
    string plusOne(string& s, int j) {
        if (s[j] == '9') {
            s[j] = '0';
        } else {
            ++s[j];
        }
        return s;
    }
    // 将 s[i] 向下拨动一次
    string minusOne(string& s, int j) {
        if (s[j] == '0') {
            s[j] = '9';
        } else {
            --s[j];
        }
        return s;
    }
public:
    int openLock(vector<string>& deadends, string target) {
        // 记录需要跳过的死亡密码
        set<string> deads;
        for (string& s : deadends) {
            deads.insert(s);
        }
        // 双向BFS，分别从起点和终点遍历
        // 用集合不用队列，可以快速判断元素是否存在
        set<string> q1, q2;
        // 记录已经穷举过的密码，防止走回头路
        set<string> visited;
        // 从起点开始启动广度优先搜索
        int step = 0;
        q1.insert("0000");
        q2.insert(target);
        visited.insert("0000");
        while (!q1.empty() && !q2.empty()) {
            // 哈希集合在遍历的过程中不能修改，用 temp 存储扩散结果
            set<string> temp;
            /* 将 q1 中的所有节点向周围扩散 */
            for (string cur : q1) {
                /* 判断是否到达终点 */
                if (deads.count(cur)) {
                    continue;
                }
                if (q2.count(cur)) {
                    return step;
                }
                visited.insert(cur);
                /* 将一个节点的未遍历相邻节点加入队列 */
                for (int j = 0; j < 4; ++j) {
                    string up = plusOne(cur, j);
                    if (!visited.count(up)) {
                        temp.insert(up);
                    }
                    string down = minusOne(cur, j);
                    down = minusOne(down, j);
                    if (!visited.count(down)) {
                        temp.insert(down);
                    }
                }
            }
            /* 在这里增加步数 */
            ++step;
            // temp 相当于 q1
            // 这里交换 q1 q2，下一轮 while 就是扩散 q2
            q1 = q2;
            q2 = temp;
        }
        // 如果穷举完都没找到目标密码，那就是找不到了
        return -1;
    }
};
```

# 二分搜索

抛开有序数组这个枯燥的数据结构，二分查找如何运用到实际的算法问题中呢？当搜索空间有序的时候，就可以通过二分搜索「剪枝」，大幅提升效率。

```java
int binary_search(int[] nums, int target) {
    int left = 0, right = nums.length - 1; 
    while(left <= right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] < target) {
            left = mid + 1;
        } else if (nums[mid] > target) {
            right = mid - 1; 
        } else if(nums[mid] == target) {
            // 直接返回
            return mid;
        }
    }
    // 直接返回
    return -1;
}

int left_bound(int[] nums, int target) {
    int left = 0, right = nums.length - 1;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] < target) {
            left = mid + 1;
        } else if (nums[mid] > target) {
            right = mid - 1;
        } else if (nums[mid] == target) {
            // 别返回，锁定左侧边界
            right = mid - 1;
        }
    }
    // 最后要检查 left 越界的情况
    if (left >= nums.length || nums[left] != target)
        return -1;
    return left;
}


int right_bound(int[] nums, int target) {
    int left = 0, right = nums.length - 1;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] < target) {
            left = mid + 1;
        } else if (nums[mid] > target) {
            right = mid - 1;
        } else if (nums[mid] == target) {
            // 别返回，锁定右侧边界
            left = mid + 1;
        }
    }
    // 最后要检查 right 越界的情况
    if (right < 0 || nums[right] != target)
        return -1;
    return right;
}
```

1. 在排序数组中查找元素的第一个和最后一个位置

   ```c++
   class Solution { 
   public:
       int binarySearch(vector<int>& nums, int target, bool lower) {
           int left = 0, right = (int)nums.size() - 1, ans = (int)nums.size();
           while (left <= right) {
               int mid = (left + right) / 2;
               if (nums[mid] > target || (lower && nums[mid] >= target)) {
                   right = mid - 1;
                   ans = mid;
               } else {
                   left = mid + 1;
               }
           }
           return ans;
       }
   
       vector<int> searchRange(vector<int>& nums, int target) {
           int leftIdx = binarySearch(nums, target, true);
           int rightIdx = binarySearch(nums, target, false) - 1;
           if (leftIdx <= rightIdx && rightIdx < nums.size() && nums[leftIdx] == target && nums[rightIdx] == target) {
               return vector<int>{leftIdx, rightIdx};
           } 
           return vector<int>{-1, -1};
       }
   };
   ```

2. 爱吃香蕉的珂珂

   描述：珂珂喜欢吃香蕉。这里有 N 堆香蕉，第 i 堆中有 piles[i] 根香蕉。警卫已经离开了，将在 H 小时后回来。

   珂珂可以决定她吃香蕉的速度 K （单位：根/小时）。每个小时，她将会选择一堆香蕉，从中吃掉 K 根。如果这堆香蕉少于 K 根，她将吃掉这堆的所有香蕉，然后这一小时内不会再吃更多的香蕉。  

   珂珂喜欢慢慢吃，但仍然想在警卫回来前吃掉所有的香蕉。

   返回她可以在 H 小时内吃掉所有香蕉的最小速度 K（K 为整数）。

   ```java
   int minEatingSpeed(int[] piles, int H) {
       // 套用搜索左侧边界的算法框架
       int left = 1, right = getMax(piles) + 1;
       while (left < right) {
           // 防止溢出
           int mid = left + (right - left) / 2;
           if (canFinish(piles, mid, H)) {
               right = mid;
           } else {
               left = mid + 1;
           }
       }
       return left;
   }
   // 时间复杂度 O(N)
   boolean canFinish(int[] piles, int speed, int H) {
       int time = 0;
       for (int n : piles) {
           time += timeOf(n, speed);
       }
       return time <= H;
   }
   
   int timeOf(int n, int speed) {
       return (n / speed) + ((n % speed > 0) ? 1 : 0);
   }
   
   int getMax(int[] piles) {
       int max = 0;
       for (int n : piles)
           max = Math.max(n, max);
       return max;
   }
   ```

3. 在D天内送达包裹的能力

   描述：传送带上的包裹必须在 D 天内从一个港口运送到另一个港口。

   传送带上的第 i 个包裹的重量为 weights[i]。每一天，我们都会按给出重量的顺序往传送带上装载包裹。我们装载的重量不会超过船的最大运载重量。

   返回能在 D 天内将传送带上的所有包裹送达的船的最低运载能力。

   ```java
   // 寻找左侧边界的二分查找
   int shipWithinDays(int[] weights, int D) {
       // 载重可能的最小值
       int left = getMax(weights);
       // 载重可能的最大值 + 1
       int right = getSum(weights) + 1;
       while (left < right) {
           int mid = left + (right - left) / 2;
           if (canFinish(weights, D, mid)) {
               right = mid;
           } else {
               left = mid + 1;
           }
       }
       return left;
   }
   
   // 如果载重为 cap，是否能在 D 天内运完货物？
   boolean canFinish(int[] w, int D, int cap) {
       int i = 0;
       for (int day = 0; day < D; day++) {
           int maxCap = cap;
           while ((maxCap -= w[i]) >= 0) {
               i++;
               if (i == w.length)
                   return true;
           }
       }
       return false;
   }
   int getMax(int[] piles) {
       int max = 0;
       for (int n : piles)
           max = Math.max(n, max);
       return max;
   }
   ```

   

# 滑动窗口

```c++
// 框架
/* 滑动窗口算法框架 */
void slidingWindow(string s, string t) {
    unordered_map<char, int> need, window;
    // 初始化需求窗口，每个值数量为1
    for (char c : t) need[c]++;
	// left = right = 0，把索引左闭右开区间[left, right)称为一个「窗口」
    int left = 0, right = 0;
    int valid = 0; 
    while (right < s.size()) {
        // c 是将移入窗口的字符
        char c = s[right];
        // 不断地增加right指针扩大窗口[left, right)，直到窗口中的字符串符合要求（包含了T中的所有字符）。
        right++;
        // 进行窗口内数据的一系列更新
        ...

        /*** debug 输出的位置 ***/
        printf("window: [%d, %d)\n", left, right);
        /********************/

        // 判断左侧窗口是否要收缩.直到窗口中的字符串不再符合要求（不包含T中的所有字符了）。同时，每次增加left，我们都要更新一轮结果。
        while (window needs shrink) {
            // d 是将移出窗口的字符
            char d = s[left];
            // 左移窗口
            left++;
            // 进行窗口内数据的一系列更新
            ...
        }
        // 直到right到达字符串S的尽头。
    }
}
```

1. 最小覆盖子串

   给你一个字符串 `s` 、一个字符串 `t` 。返回 `s` 中涵盖 `t` 所有字符的最小子串。如果 `s` 中不存在涵盖 `t` 所有字符的子串，则返回空字符串 `""` 。

   ```c++
   string minWindow(string s, string t) {
       unordered_map<char, int> need, window;
       for (char c : t) need[c]++;
   
       int left = 0, right = 0;
       int valid = 0;
       // 记录最小覆盖子串的起始索引及长度
       int start = 0, len = INT_MAX;
       while (right < s.size()) {
           // c 是将移入窗口的字符
           char c = s[right];
           // 右移窗口
           right++;
           // 进行窗口内数据的一系列更新
           if (need.count(c)) {
               window[c]++;
               if (window[c] == need[c])
                   valid++;
           }
   
           // 判断左侧窗口是否要收缩
           while (valid == need.size()) {
               // 在这里更新最小覆盖子串
               if (right - left < len) {
                   start = left;
                   len = right - left;
               }
               // d 是将移出窗口的字符
               char d = s[left];
               // 左移窗口
               left++;
               // 进行窗口内数据的一系列更新
               if (need.count(d)) {
                   if (window[d] == need[d])
                       valid--;
                   window[d]--;
               }                    
           }
       }
       // 返回最小覆盖子串
       return len == INT_MAX ?
           "" : s.substr(start, len);
   }
   ```

2. 字符串的排列

   给定两个字符串 `s1` 和 `s2`，写一个函数来判断 `s2` 是否包含 `s1` 的排列。

   换句话说，第一个字符串的排列之一是第二个字符串的 **子串** 。

   ```c++
   // 判断 s 中是否存在 t 的排列
   bool checkInclusion(string t, string s) {
       unordered_map<char, int> need, window;
       for (char c : t) need[c]++;
   
       int left = 0, right = 0;
       int valid = 0;
       while (right < s.size()) {
           char c = s[right];
           right++;
           // 进行窗口内数据的一系列更新
           if (need.count(c)) {
               window[c]++;
               if (window[c] == need[c])
                   valid++;
           }
   
           // 判断左侧窗口是否要收缩
           while (right - left >= t.size()) {
               // 在这里判断是否找到了合法的子串
               if (valid == need.size())
                   return true;
               char d = s[left];
               left++;
               // 进行窗口内数据的一系列更新
               if (need.count(d)) {
                   if (window[d] == need[d])
                       valid--;
                   window[d]--;
               }
           }
       }
       // 未找到符合条件的子串
       return false;
   }
   // 优化：双指针方法
   class Solution {
   public:
       bool checkInclusion(string s1, string s2) {
           int n = s1.length(), m = s2.length();
           if (n > m) {
               return false;
           }
           vector<int> cnt(26);
           for (int i = 0; i < n; ++i) {
               --cnt[s1[i] - 'a'];
           }
           int left = 0;
           for (int right = 0; right < m; ++right) {
               int x = s2[right] - 'a';
               ++cnt[x];
               while (cnt[x] > 0) {
                   --cnt[s2[left] - 'a'];
                   ++left;
               }
               if (right - left + 1 == n) {
                   return true;
               }
           }
           return false;
       }
   };
   ```

3. 找到字符串中所有字母异位词

   给定一个字符串 s 和一个非空字符串 p，找到 s 中所有是 p 的字母异位词的子串，返回这些子串的起始索引。

   字符串只包含小写英文字母，并且字符串 s 和 p 的长度都不超过 20100。

   说明：

   字母异位词指字母相同，但排列不同的字符串。
   不考虑答案输出的顺序。

   ```c++
   vector<int> findAnagrams(string s, string t) {
       unordered_map<char, int> need, window;
       for (char c : t) need[c]++;
   
       int left = 0, right = 0;
       int valid = 0;
       vector<int> res; // 记录结果
       while (right < s.size()) {
           char c = s[right];
           right++;
           // 进行窗口内数据的一系列更新
           if (need.count(c)) {
               window[c]++;
               if (window[c] == need[c]) 
                   valid++;
           }
           // 判断左侧窗口是否要收缩
           while (right - left >= t.size()) {
               // 当窗口符合条件时，把起始索引加入 res
               if (valid == need.size())
                   res.push_back(left);
               char d = s[left];
               left++;
               // 进行窗口内数据的一系列更新
               if (need.count(d)) {
                   if (window[d] == need[d])
                       valid--;
                   window[d]--;
               }
           }
       }
       return res;
   }
   ```
   
4. 最长无重复子串

   给定一个字符串，请你找出其中不含有重复字符的 **最长子串** 的长度。

   ```c++
   int lengthOfLongestSubstring(string s) {
       unordered_map<char, int> window;
   
       int left = 0, right = 0;
       int res = 0; // 记录结果
       while (right < s.size()) {
           char c = s[right];
           right++;
           // 进行窗口内数据的一系列更新
           window[c]++;
           // 判断左侧窗口是否要收缩
           while (window[c] > 1) {
               char d = s[left];
               left++;
               // 进行窗口内数据的一系列更新
               window[d]--;
           }
           // 在这里更新答案
           res = max(res, right - left);
       }
       return res;
   }
   ```

5. 滑动窗口最大值

   描述：给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。

   返回滑动窗口中的最大值。

   ```java
   /* 单调队列的实现 */
   class MonotonicQueue {
       LinkedList<Integer> q = new LinkedList<>();
       public void push(int n) {
           // 将小于 n 的元素全部删除
           while (!q.isEmpty() && q.getLast() < n) {
               q.pollLast();
           }
           // 然后将 n 加入尾部
           q.addLast(n);
       }
   
       public int max() {
           return q.getFirst();
       }
   
       public void pop(int n) {
           if (n == q.getFirst()) {
               q.pollFirst();
           }
       }
   }
   
   /* 解题函数的实现 */
   int[] maxSlidingWindow(int[] nums, int k) {
       MonotonicQueue window = new MonotonicQueue();
       List<Integer> res = new ArrayList<>();
   
       for (int i = 0; i < nums.length; i++) {
           if (i < k - 1) {
               //先填满窗口的前 k - 1
               window.push(nums[i]);
           } else {
               // 窗口向前滑动，加入新数字
               window.push(nums[i]);
               // 记录当前窗口的最大值
               res.add(window.max());
               // 移出旧数字
               window.pop(nums[i - k + 1]);
           }
       }
       // 需要转成 int[] 数组再返回
       int[] arr = new int[res.size()];
       for (int i = 0; i < res.size(); i++) {
           arr[i] = res.get(i);
       }
       return arr;
   }
   ```

   

# 股票买卖问题

**思路：**

- 穷举框架：我们要穷举所有「状态」，穷举的目的是根据对应的「选择」更新状态。

  ```c++
  for 状态1 in 状态1的所有取值：
      for 状态2 in 状态2的所有取值：
          for ...
              dp[状态1][状态2][...] = 择优(选择1，选择2...)
  ```

  **每天都有三种「选择」**：买入、卖出、无操作，我们用 buy, sell, rest 表示这三种选择。

  **这个问题的「状态」有三个**，第一个是天数，第二个是允许交易的最大次数，第三个是当前的持有状态（即之前说的 rest 的状态，我们不妨用 1 表示持有，0 表示没有持有）。然后我们用一个三维数组就可以装下这几种状态的全部组合：

  ```c++
  dp[i][k][0 or 1]
  0 <= i <= n-1, 1 <= k <= K
  n 为天数，大 K 为最多交易数
  此问题共 n × K × 2 种状态，全部穷举就能搞定。
  
  for 0 <= i < n:
      for 1 <= k <= K:
          for s in {0, 1}:
              dp[i][k][s] = max(buy, sell, rest)
  ```

- 状态转移框架

  ![img](pic\001.jpg)

  ```
  dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])
                max(   选择 rest  ,             选择 sell      )
  
  	解释：今天我没有持有股票，有两种可能：
  			1.要么是我昨天就没有持有，然后今天选择 rest，所以我今天还是没有持有；
  			2.要么是我昨天持有股票，但是今天我 sell 了，所以我今天没有持有股票了。
  
  dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])
                max(   选择 rest  ,           选择 buy         )
  
  	解释：今天我持有着股票，有两种可能：
              1.要么我昨天就持有着股票，然后今天选择 rest，所以我今天还持有着股票；
              2.要么我昨天本没有持有，但今天我选择 buy，所以今天我就持有股票了。
  
  定义 base case：
      dp[-1][k][0] = 0
     		解释：因为 i 是从 0 开始的，所以 i = -1 意味着还没有开始，这时候的利润当然是 0 。
      dp[-1][k][1] = -infinity
      	解释：还没开始的时候，是不可能持有股票的，用负无穷表示这种不可能。
      dp[i][0][0] = 0
      	解释：因为 k 是从 1 开始的，所以 k = 0 意味着根本不允许交易，这时候利润当然是 0 。
      dp[i][0][1] = -infinity
      	解释：不允许交易的情况下，是不可能持有股票的，用负无穷表示这种不可能。
  ```

  ```c++
  总结：
  base case：
  dp[-1][k][0] = dp[i][0][0] = 0
  dp[-1][k][1] = dp[i][0][1] = -infinity
  
  状态转移方程：
  dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])
  dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])
  ```

  

1. k=1

   描述：给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。

   你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。

   返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。

   ```java
   // k == 1思路
   dp[i][1][0] = max(dp[i-1][1][0], dp[i-1][1][1] + prices[i])
   dp[i][1][1] = max(dp[i-1][1][1], dp[i-1][0][0] - prices[i]) 
               = max(dp[i-1][1][1], -prices[i])
   解释：k = 0 的 base case，所以 dp[i-1][0][0] = 0。
   
   现在发现 k 都是 1，不会改变，即 k 对状态转移已经没有影响了。
   可以进行进一步化简去掉所有 k：
   // 答案
   int maxProfit_k_1(int[] prices) {
       int n = prices.length;
       // base case: dp[-1][0] = 0, dp[-1][1] = -infinity
       int dp_i_0 = 0, dp_i_1 = Integer.MIN_VALUE;
       for (int i = 0; i < n; i++) {
           // 1.没有持有：昨天也没持有和昨天持有但今天卖掉的最大值
           dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]);
           // 持有：昨天持有今天依旧持有和今天买入的最大值
           dp_i_1 = Math.max(dp_i_1, -prices[i]);
       }
       // 最后的状态是不持有下的最大值
       return dp_i_0;
   }
   ```

2. k=正无穷

   描述：给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。

   设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。

   注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

   ```java
   如果 k 为正无穷，那么就可以认为 k 和 k - 1 是一样的
   dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])
   dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])
               = max(dp[i-1][k][1], dp[i-1][k][0] - prices[i])
   
   我们发现数组中的 k 已经不会改变了，也就是说不需要记录 k 这个状态了：
   int maxProfit_k_inf(int[] prices) {
       int n = prices.length;
       int dp_i_0 = 0, dp_i_1 = Integer.MIN_VALUE;
       for (int i = 0; i < n; i++) {
           // 暂时记录目前不持有时的利润
           int temp = dp_i_0;
           // 不买入和卖出的收益最大者
           dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]);
           // 继续保持持有和原本不持有现在买入的最大者
           dp_i_1 = Math.max(dp_i_1, temp - prices[i]);
       }
       return dp_i_0;
   }
   ```

3. k = +infinity with cooldown含冷冻期

   描述：给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。

   设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:

   你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
   卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。

   ```java
   int maxProfit_with_cool(int[] prices) {
       int n = prices.length;
       int dp_i_0 = 0, dp_i_1 = Integer.MIN_VALUE;
       int dp_pre_0 = 0; // 代表 dp[i-2][0]
       for (int i = 0; i < n; i++) {
           // 存储dp[i-1][0]
           int temp = dp_i_0;
           // 解释：第 i 天选择 buy 的时候，要从 i-2 的状态转移，而不是 i-1 。
           dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]);
           dp_i_1 = Math.max(dp_i_1, dp_pre_0 - prices[i]);
           // 此时temp变成了第i-2天的利润。存储dp[i-2][0]
           dp_pre_0 = temp;
       }
       return dp_i_0;
   }
   ```

4. k = +infinity with fee每次交易要支付手续费

   把手续费从利润中减去即可

   ```java
   int maxProfit_with_fee(int[] prices, int fee) {
       int n = prices.length;
       int dp_i_0 = 0, dp_i_1 = Integer.MIN_VALUE;
       for (int i = 0; i < n; i++) {
           int temp = dp_i_0;
           // 在第一个式子里减也是一样的，相当于卖出股票的价格减小了。
           dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]);
           // 相当于买入股票的价格升高了。
           dp_i_1 = Math.max(dp_i_1, temp - prices[i] - fee);
       }
       return dp_i_0;
   }
   ```

5. k = 2

   描述：给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。

   设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。

   注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

   这道题由于没有消掉 k 的影响，所以必须要对 k 进行穷举：

   ```java
   // 思路：
   int max_k = 2;
   int[][][] dp = new int[n][max_k + 1][2];
   for (int i = 0; i < n; i++) {
       for (int k = max_k; k >= 1; k--) {
           if (i - 1 == -1) { /*处理 base case */ }
           dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]);
           dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]);
       }
   }
   // 穷举了 n × max_k × 2 个状态，正确。
   return dp[n - 1][max_k][0];
   
   // 这里 k 取值范围比较小，所以可以不用 for 循环，直接把 k = 1 和 2 的情况全部列举出来也可以：
   int maxProfit_k_2(int[] prices) {
       int dp_i10 = 0, dp_i11 = Integer.MIN_VALUE;
       int dp_i20 = 0, dp_i21 = Integer.MIN_VALUE;
       for (int price : prices) {
           dp_i20 = Math.max(dp_i20, dp_i21 + price);
           dp_i21 = Math.max(dp_i21, dp_i10 - price);
           dp_i10 = Math.max(dp_i10, dp_i11 + price);
           dp_i11 = Math.max(dp_i11, -price);
       }
       return dp_i20;
   }
   ```

6. k = any integer

   描述：给定一个整数数组 prices ，它的第 i 个元素 prices[i] 是一支给定的股票在第 i 天的价格。

   设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。

   注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

   思路：有了上一题 k = 2 的铺垫，这题应该和上一题的第一个解法没啥区别。但是出现了一个超内存的错误，原来是传入的 k 值会非常大，dp 数组太大了。现在想想，交易次数 k 最多有多大呢？

   一次交易由买入和卖出构成，至少需要两天。所以说有效的限制 k 应该不超过 n/2，如果超过，就没有约束作用了，相当于 k = +infinity。这种情况是之前解决过的。

   ```java
   int maxProfit_k_any(int max_k, int[] prices) {
       int n = prices.length;
       if (max_k > n / 2) 
           return maxProfit_k_inf(prices);
   
       int[][][] dp = new int[n][max_k + 1][2];
       for (int i = 0; i < n; i++) 
           for (int k = max_k; k >= 1; k--) {
               if (i - 1 == -1) { /* 处理 base case */ }
               dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]);
               dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]);     
           }
       return dp[n - 1][max_k][0];
   }
   ```

# 区间问题

所谓区间问题，就是线段问题，让你合并所有线段、找出线段的交集等等。主要有两个技巧：

**1、排序**。常见的排序方法就是按照区间起点排序，或者先按照起点升序排序，若起点相同，则按照终点降序排序。

**2、画图**。两个区间的相对位置到底有几种可能，不同的相对位置我们的代码应该怎么去处理。

1. 删除被覆盖的区间

   描述：给你一个区间列表，请你删除列表中被其他区间所覆盖的区间。

   只有当 c <= a 且 b <= d 时，我们才认为区间 [a,b) 被区间 [c,d) 覆盖。

   在完成所有删除操作后，请你返回列表中剩余区间的数目。

   思路：排序之后，两个相邻区间可能有如下三种相对位置：

   ![Image](pic\003.jpg)

   对于情况一，找到了覆盖区间。

   对于情况二，两个区间可以合并，成一个大区间。

   对于情况三，两个区间完全不相交。

   ```java
   int removeCoveredIntervals(int[][] intvs) {
       // 按照起点升序排列，起点相同时降序排列
       Arrays.sort(intvs, (a, b) -> {
           if (a[0] == b[0]) {
               return b[1] - a[1];
           }
           return a[0] - b[0]; 
       });
   
       // 记录合并区间的起点和终点
       int left = intvs[0][0];
       int right = intvs[0][1];
   
       int res = 0;
       for (int i = 1; i < intvs.length; i++) {
           int[] intv = intvs[i];
           // 情况一，找到覆盖区间
           if (left <= intv[0] && right >= intv[1]) {
               res++;
           }
           // 情况二，找到相交区间，合并
           if (right >= intv[0] && right <= intv[1]) {
               right = intv[1];
           }
           // 情况三，完全不相交，更新起点和终点
           if (right < intv[0]) {
               left = intv[0];
               right = intv[1];
           }
       }
   
       return intvs.length - res;
   }
   ```

2. 合并区间

   描述：以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。

   ```c++
   vector<vector<int>> merge(vector<vector<int>>& intervals) {
       int n = intervals.size();
       vector<vector<int>> res;
       if (0 == n) {
           return res;
       }
       sort(intervals.begin(), intervals.end());
       for (int i = 0; i < n; ++i) {
           int L = intervals[i][0], R = intervals[i][1];
           if (!res.size() || res.back()[1] < L) {
               res.push_back({L, R});
           } else {
               res.back()[1] = max(res.back()[1], R);
           }
       }
       return res;
   }
   ```

3. 区间列表的交集

   描述：给定两个由一些 闭区间 组成的列表，firstList 和 secondList ，其中 firstList[i] = [starti, endi] 而 secondList[j] = [startj, endj] 。每个区间列表都是成对 不相交 的，并且 已经排序 。

   返回这 两个区间列表的交集 。

   形式上，闭区间 [a, b]（其中 a <= b）表示实数 x 的集合，而 a <= x <= b 。

   两个闭区间的 交集 是一组实数，要么为空集，要么为闭区间。例如，[1, 3] 和 [2, 4] 的交集为 [2, 3] 。

   思路：用两个索引指针在`A`和`B`中游走，把交集找出来

   **对于两个区间**，用`[a1,a2]`和`[b1,b2]`表示在`A`和`B`中的两个区间

   ![Image](pic\005.jpg)

   如果交集区间是`[c1,c2]`，那么`c1=max(a1,b1)`，`c2=min(a2,b2)`！这一点就是寻找交集的核心

   是否前进，只取决于`a2`和`b2`的大小关系

   ```python
   # A, B 形如 [[0,2],[5,10]...]
   def intervalIntersection(A, B):
       i, j = 0, 0 # 双指针
       res = []
       while i < len(A) and j < len(B):
           a1, a2 = A[i][0], A[i][1]
           b1, b2 = B[j][0], B[j][1]
           # 两个区间存在交集
           if b2 >= a1 and a2 >= b1:
               # 计算出交集，加入 res
               res.append([max(a1, b1), min(a2, b2)])
           # 指针前进
           if b2 < a2: j += 1
           else:       i += 1
       return res
   ```

# nSum

1. 两数之和3-数据结构设计

   描述：设计一个接收整数流的数据结构，该数据结构支持检查是否存在两数之和等于特定值。

   实现 TwoSum 类：

   TwoSum() 使用空数组初始化 TwoSum 对象
   void add(int number) 向数据结构添加一个数 number
   boolean find(int value) 寻找数据结构中是否存在一对整数，使得两数之和与给定的值相等。如果存在，返回 true ；否则，返回 false 。

   ```java
   # 方法一
   class TwoSum {
       Map<Integer, Integer> freq = new HashMap<>();
   
       public void add(int number) {
           // 记录 number 出现的次数
           freq.put(number, freq.getOrDefault(number, 0) + 1);
       }
   
       public boolean find(int value) {
           for (Integer key : freq.keySet()) {
               int other = value - key;
               // 情况一
               if (other == key && freq.get(key) > 1)
                   return true;
               // 情况二
               if (other != key && freq.containsKey(other))
                   return true;
           }
           return false;
       }
   }
   
   # 方法二
   class TwoSum {
       Set<Integer> sum = new HashSet<>();
       List<Integer> nums = new ArrayList<>();
   
       public void add(int number) {
           // 记录所有可能组成的和
           for (int n : nums)
               sum.add(n + number);
           nums.add(number);
       }
   
       public boolean find(int value) {
           return sum.contains(value);
       }
   }
   ```




2. 三数之和

   描述：给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。

   注意：答案中不可以包含重复的三元组。

   思路：穷举，得出第一个数字，用双指针找另外两个数。

   ```c++
   vector<vector<int>> threeSum(vector<int>& nums) {
       int n = nums.size();
       vector<vector<int>> result;
       // 升序排序
       sort(nums.begin(), nums.end());
       // 轮流取第一个数字。和为0的话第一个一定是负数。
       for (int i = 0; i < n; ++i) {
           if (nums[i] > 0) {
               return result;
           }
           // 略过相同的数字
           if (i > 0 && nums[i] == nums[i - 1]) {
               continue;
           }
           // 双指针遍历
           int j = i + 1, k = n - 1;
           while (j < k) {
               if (nums[i] + nums[j] > 0) {
                   break;
               }
               if (nums[i] + nums[j] + nums[k] < 0) {
                   ++j;
                   // 跳过相同数字
                   while (j < k && nums[j] == nums[j - 1]) ++j;
               } else if (nums[i] + nums[j] + nums[k] > 0) {
                   --k;
                   while (j < k && nums[k] == nums[k + 1]) --k;
               } else {
                   result.push_back({nums[i], nums[j], nums[k]});
                   ++j;
                   --k;
                   while (j < k && nums[j] == nums[j - 1]) ++j;
                   while (j < k && nums[k] == nums[k + 1]) --k;
               }
           }
       }
       return result;
   }
   ```

3. 四数之和

   描述：给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。

   注意：答案中不可以包含重复的四元组。

   ```c++
   class Solution {
       vector<vector<int>> twoSumTarget(vector<int>& nums, int start, int target) {
           // nums 数组必须有序
           sort(nums.begin(), nums.end());
           int lo = start, hi = nums.size() - 1;
           vector<vector<int>> res;
           while (lo < hi) {
               int sum = nums[lo] + nums[hi];
               int left = nums[lo], right = nums[hi];
               if (sum < target) {
                   while (lo < hi && nums[lo] == left) lo++;
               } else if (sum > target) {
                   while (lo < hi && nums[hi] == right) hi--;
               } else {
                   res.push_back({left, right});
                   while (lo < hi && nums[lo] == left) lo++;
                   while (lo < hi && nums[hi] == right) hi--;
               }
           }
           return res;
       }
       vector<vector<int>> threeSumTarget(vector<int>& nums, int start, int target) {
           // 数组得排个序
           sort(nums.begin(), nums.end());
           int n = nums.size();
           vector<vector<int>> res;
           // 穷举 threeSum 的第一个数
           for (int i = start; i < n; i++) {
               // 对 target - nums[i] 计算 twoSum
               vector<vector<int>> 
                   tuples = twoSumTarget(nums, i + 1, target - nums[i]);
               // 如果存在满足条件的二元组，再加上 nums[i] 就是结果三元组
               for (vector<int>& tuple : tuples) {
                   tuple.push_back(nums[i]);
                   res.push_back(tuple);
               }
               // 跳过第一个数字重复的情况，否则会出现重复结果
               while (i < n - 1 && nums[i] == nums[i + 1]) i++;
           }
           return res;
       }
   public:
       vector<vector<int>> fourSum(vector<int>& nums, int target) {
           // 数组需要排序
           sort(nums.begin(), nums.end());
           int n = nums.size();
           vector<vector<int>> res;
           // 穷举 fourSum 的第一个数
           for (int i = 0; i < n; i++) {
               // 对 target - nums[i] 计算 threeSum
               vector<vector<int>> 
                   triples = threeSumTarget(nums, i + 1, target - nums[i]);
               // 如果存在满足条件的三元组，再加上 nums[i] 就是结果四元组
               for (vector<int>& triple : triples) {
                   triple.push_back(nums[i]);
                   res.push_back(triple);
               }
               // fourSum 的第一个数不能重复
               while (i < n - 1 && nums[i] == nums[i + 1]) i++;
           }
           return res;
       }
   };
   ```

总结：100Sum

`n == 2` 时是 `twoSum` 的双指针解法，`n > 2` 时就是穷举第一个数字，然后递归调用计算 `(n-1)Sum`，组装答案。

```c++
/* 注意：调用这个函数之前一定要先给 nums 排序 */
vector<vector<int>> nSumTarget(
    vector<int>& nums, int n, int start, int target) {

    int sz = nums.size();
    vector<vector<int>> res;
    // 至少是 2Sum，且数组大小不应该小于 n
    if (n < 2 || sz < n) return res;
    // 2Sum 是 base case
    if (n == 2) {
        // 双指针那一套操作
        int lo = start, hi = sz - 1;
        while (lo < hi) {
            int sum = nums[lo] + nums[hi];
            int left = nums[lo], right = nums[hi];
            if (sum < target) {
                while (lo < hi && nums[lo] == left) lo++;
            } else if (sum > target) {
                while (lo < hi && nums[hi] == right) hi--;
            } else {
                res.push_back({left, right});
                while (lo < hi && nums[lo] == left) lo++;
                while (lo < hi && nums[hi] == right) hi--;
            }
        }
    } else {
        // n > 2 时，递归计算 (n-1)Sum 的结果
        for (int i = start; i < sz; i++) {
            vector<vector<int>> 
                sub = nSumTarget(nums, n - 1, i + 1, target - nums[i]);
            for (vector<int>& arr : sub) {
                // (n-1)Sum 加上 nums[i] 就是 nSum
                arr.push_back(nums[i]);
                res.push_back(arr);
            }
            while (i < sz - 1 && nums[i] == nums[i + 1]) i++;
        }
    }
    return res;
}
```

# 二叉树

**写树相关的算法，简单说就是，先搞清楚当前** **`root`** **节点该做什么，然后根据函数定义递归调用子节点**，递归调用会让孩子节点做相同的事情。

1. 翻转二叉树

   ```java
   // 将整棵树的节点翻转
   TreeNode invertTree(TreeNode root) {
       // base case
       if (root == null) {
           return null;
       }
   
       /**** 前序遍历位置 ****/
       // root 节点需要交换它的左右子节点
       TreeNode tmp = root.left;
       root.left = root.right;
       root.right = tmp;
   
       // 让左右子节点继续翻转它们的子节点
       invertTree(root.left);
       invertTree(root.right);
   
       return root;
   }
   ```

2. 填充二叉树节点的右侧指针

   描述：给定一个 **完美二叉树** ，其所有叶子节点都在同一层，每个父节点都有两个子节点。

   思路：把二叉树的每一层节点都用 `next` 指针连接起来

   ```java
   // 主函数
   Node connect(Node root) {
       if (root == null) return null;
       connectTwoNode(root.left, root.right);
       return root;
   }
   
   // 辅助函数
   void connectTwoNode(Node node1, Node node2) {
       if (node1 == null || node2 == null) {
           return;
       }
       /**** 前序遍历位置 ****/
       // 将传入的两个节点连接
       node1.next = node2;
   
       // 连接相同父节点的两个子节点
       connectTwoNode(node1.left, node1.right);
       connectTwoNode(node2.left, node2.right);
       // 连接跨越父节点的两个子节点
       connectTwoNode(node1.right, node2.left);
   }
   ```

3. 将二叉树展开为链表

   描述：给你二叉树的根结点 root ，请你将它展开为一个单链表：

   展开后的单链表应该同样使用 TreeNode ，其中 right 子指针指向链表中下一个结点，而左子指针始终为 null 。
   展开后的单链表应该与二叉树 先序遍历 顺序相同。

   思路：将 `root` 的左子树和右子树拉平。将 `root` 的右子树接到左子树下方，然后将整个左子树作为右子树。

   ![img](pic\006.jpg)

   ```java
   // 定义：将以 root 为根的树拉平为链表
   void flatten(TreeNode root) {
       // base case
       if (root == null) return;
   
       flatten(root.left);
       flatten(root.right);
   
       /**** 后序遍历位置 ****/
       // 1、左右子树已经被拉平成一条链表
       TreeNode left = root.left;
       TreeNode right = root.right;
   
       // 2、将左子树作为右子树
       root.left = null;
       root.right = left;
   
       // 3、将原先的右子树接到当前右子树的末端
       TreeNode p = root;
       while (p.right != null) {
           p = p.right;
       }
       p.right = right;
   }
   ```


4. 最大二叉树

   描述：给定一个不含重复元素的整数数组 nums 。一个以此数组直接递归构建的 最大二叉树 定义如下：

   二叉树的根是数组 nums 中的最大元素。
   左子树是通过数组中 最大值左边部分 递归构造出的最大二叉树。
   右子树是通过数组中 最大值右边部分 递归构造出的最大二叉树。
   返回有给定数组 nums 构建的 最大二叉树 。

   思路：把题目的要求细化，搞清楚根节点应该做什么，然后剩下的事情抛给前/中/后序的遍历框架。我们肯定要遍历数组把找到最大值 `maxVal`，把根节点 `root` 做出来，然后对 `maxVal` 左边的数组和右边的数组进行递归调用，作为 `root` 的左右子树。

   ```java
   /* 主函数 */
   TreeNode constructMaximumBinaryTree(int[] nums) {
       return build(nums, 0, nums.length - 1);
   }
   
   /* 将 nums[lo..hi] 构造成符合条件的树，返回根节点 */
   TreeNode build(int[] nums, int lo, int hi) {
       // base case
       if (lo > hi) {
           return null;
       }
   
       // 找到数组中的最大值和对应的索引
       int index = -1, maxVal = Integer.MIN_VALUE;
       for (int i = lo; i <= hi; i++) {
           if (maxVal < nums[i]) {
               index = i;
               maxVal = nums[i];
           }
       }
   
       TreeNode root = new TreeNode(maxVal);
       // 递归调用构造左右子树
       root.left = build(nums, lo, index - 1);
       root.right = build(nums, index + 1, hi);
   
       return root;
   }
   ```

5. 从前序与中序遍历序列构造二叉树

   ```c++
   class Solution {
       map<int, int> inMap;
       TreeNode* buildTree(vector<int>& preorder, int prestart, int preend, vector<int>& inorder, int instart, int inend) {
           if (prestart > preend || instart > inend) {
               return nullptr;
           }
           int rootval = preorder[prestart];
           TreeNode* root = new TreeNode(rootval);
           int inroot = inMap[rootval];
           int leftLen = inroot - instart;
           root->left = buildTree(preorder, prestart + 1, prestart + leftLen, inorder, instart, inroot - 1);
           root->right = buildTree(preorder, prestart + leftLen + 1, preend, inorder, inroot + 1, inend);
           return root;
       }
   public:
       TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
           for (int i = 0; i < inorder.size(); ++i) {
               inMap[inorder[i]] = i;
           }
           return buildTree(preorder, 0, preorder.size() - 1, inorder, 0, inorder.size() - 1);
       }
   };
   ```

6. 从中序与后序遍历序列构造二叉树

   ```java
   TreeNode buildTree(int[] inorder, int[] postorder) {
       return build(inorder, 0, inorder.length - 1,
                    postorder, 0, postorder.length - 1);
   }
   TreeNode build(int[] inorder, int inStart, int inEnd,
                  int[] postorder, int postStart, int postEnd) {
   
       if (inStart > inEnd) {
           return null;
       }
       // root 节点对应的值就是后序遍历数组的最后一个元素
       int rootVal = postorder[postEnd];
       // rootVal 在中序遍历数组中的索引
       int index = 0;
       for (int i = inStart; i <= inEnd; i++) {
           if (inorder[i] == rootVal) {
               index = i;
               break;
           }
       }
       // 左子树的节点个数
       int leftSize = index - inStart;
       TreeNode root = new TreeNode(rootVal);
       // 递归构造左右子树
       root.left = build(inorder, inStart, index - 1,
                           postorder, postStart, postStart + leftSize - 1);
   
       root.right = build(inorder, index + 1, inEnd,
                           postorder, postStart + leftSize, postEnd - 1);
       return root;
   }
   ```

7. 寻找重复的子树

   描述：给定一棵二叉树，返回所有重复的子树。对于同一类的重复子树，你只需要返回其中任意**一棵**的根结点即可。

   两棵树重复是指它们具有相同的结构以及相同的结点值。

   思路：你需要知道以下两点：
   
   1、以我为根的这棵二叉树（子树）长啥样？
   
   2、以其他节点为根的子树都长啥样？
   
   使用后序遍历。
   
   ```java
   // 记录所有子树以及出现的次数
   HashMap<String, Integer> memo = new HashMap<>();
   // 记录重复的子树根节点
   LinkedList<TreeNode> res = new LinkedList<>();
   
   /* 主函数 */
   List<TreeNode> findDuplicateSubtrees(TreeNode root) {
       traverse(root);
       return res;
   }
   
   /* 辅助函数 */
   String traverse(TreeNode root) {
       if (root == null) {
           return "#";
       }
   
       String left = traverse(root.left);
       String right = traverse(root.right);
   
       String subTree = left + "," + right+ "," + root.val;
   
       int freq = memo.getOrDefault(subTree, 0);
       // 多次重复也只会被加入结果集一次
       if (freq == 1) {
           res.add(root);
       }
       // 给子树对应的出现次数加一
       memo.put(subTree, freq + 1);
       return subTree;
   }
   ```

8. 二叉树的序列号与反序列化

   描述：序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。

   请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。

   思路：反序列化**先确定根节点 `root`，然后遵循前序遍历的规则，递归生成左右子树即可**。

   - 前序解法

   ```java
   String SEP = ",";
   String NULL = "#";
   
   /* 主函数，将二叉树序列化为字符串 */
   // 1,2,#,4,#,#,3,#,#,
   String serialize(TreeNode root) {
       StringBuilder sb = new StringBuilder();
       serialize(root, sb);
       return sb.toString();
   }
   
   /* 辅助函数，将二叉树存入 StringBuilder */
   void serialize(TreeNode root, StringBuilder sb) {
       if (root == null) {
           sb.append(NULL).append(SEP);
           return;
       }
   
       /****** 前序遍历位置 ******/
       sb.append(root.val).append(SEP);
       /***********************/
   
       serialize(root.left, sb);
       serialize(root.right, sb);
   }
   /* 主函数，将字符串反序列化为二叉树结构 */
   TreeNode deserialize(String data) {
       // 将字符串转化成列表
       LinkedList<String> nodes = new LinkedList<>();
       for (String s : data.split(SEP)) {
           nodes.addLast(s);
       }
       return deserialize(nodes);
   }
   
   /* 辅助函数，通过 nodes 列表构造二叉树 */
   TreeNode deserialize(LinkedList<String> nodes) {
       if (nodes.isEmpty()) return null;
   
       /****** 前序遍历位置 ******/
       // 列表最左侧就是根节点
       String first = nodes.removeFirst();
       if (first.equals(NULL)) return null;
       TreeNode root = new TreeNode(Integer.parseInt(first));
       /***********************/
   
       root.left = deserialize(nodes);
       root.right = deserialize(nodes);
   
       return root;
   }
   ```

   - 层次解法

   ```
   String SEP = ",";
   String NULL = "#";
   
   /* 将二叉树序列化为字符串 */
   String serialize(TreeNode root) {
       if (root == null) return "";
       StringBuilder sb = new StringBuilder();
       // 初始化队列，将 root 加入队列
       Queue<TreeNode> q = new LinkedList<>();
       q.offer(root);
   
       while (!q.isEmpty()) {
           TreeNode cur = q.poll();
   
           /* 层级遍历代码位置 */
           if (cur == null) {
               sb.append(NULL).append(SEP);
               continue;
           }
           sb.append(cur.val).append(SEP);
           /*****************/
   
           q.offer(cur.left);
           q.offer(cur.right);
       }
   
       return sb.toString();
   }
   /* 将字符串反序列化为二叉树结构 */
   TreeNode deserialize(String data) {
       if (data.isEmpty()) return null;
       String[] nodes = data.split(SEP);
       // 第一个元素就是 root 的值
       TreeNode root = new TreeNode(Integer.parseInt(nodes[0]));
   
       // 队列 q 记录父节点，将 root 加入队列
       Queue<TreeNode> q = new LinkedList<>();
       q.offer(root);
   
       for (int i = 1; i < nodes.length; ) {
           // 队列中存的都是父节点
           TreeNode parent = q.poll();
           // 父节点对应的左侧子节点的值
           String left = nodes[i++];
           if (!left.equals(NULL)) {
               parent.left = new TreeNode(Integer.parseInt(left));
               q.offer(parent.left);
           } else {
               parent.left = null;
           }
           // 父节点对应的右侧子节点的值
           String right = nodes[i++];
           if (!right.equals(NULL)) {
               parent.right = new TreeNode(Integer.parseInt(right));
               q.offer(parent.right);
           } else {
               parent.right = null;
           }
       }
       return root;
   }
   ```

9. 二叉树的最近公共祖先LCA

   背景：分支合并：`merge`和`rebase`两种方式。如果带上上参数`git pull -r`，就会使用`rebase`的方式将远端修改拉到本地。这二者最直观的区别就是：`merge`方式合并的分支会有很多「分叉」，而`rebase`方式合并的分支就是一条直线。**实际工作中更推荐使用`rebase`方式合并代码**。**首先，找到这两条分支的最近公共祖先`LCA`，然后从`master`节点开始，重演`LCA`到`dev`几个`commit`的修改**，如果这些修改和`LCA`到`master`的`commit`有冲突，就会提示你手动解决冲突，最后的结果就是把`dev`的分支完全接到`master`上面。

   思路：**遇到任何递归型的问题，无非就是灵魂三问**：

   **1、这个函数是干嘛的**？

   **2、这个函数参数中的变量是什么的是什么**？

   **3、得到函数的递归结果，你应该干什么**？

   给该函数输入三个参数`root`，`p`，`q`，它会返回一个节点。

   情况 1，如果`p`和`q`都在以`root`为根的树中，函数返回的即使`p`和`q`的最近公共祖先节点。

   情况 2，那如果`p`和`q`都不在以`root`为根的树中怎么办呢？函数理所当然地返回`null`呗。

   情况 3，那如果`p`和`q`只有一个存在于`root`为根的树中呢？函数就会返回那个节点。

   每次递归在做什么？不就是在把「以`root`为根」转移成「以`root`的子节点为根」，不断缩小问题规模嘛？

   后序遍历。

   ```java
   TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
       // base case
       if (root == null) return null;
       if (root == p || root == q) return root;
   
       TreeNode left = lowestCommonAncestor(root.left, p, q);
       TreeNode right = lowestCommonAncestor(root.right, p, q);
       // 情况 1
       if (left != null && right != null) {
           return root;
       }
       // 情况 2
       if (left == null && right == null) {
           return null;
       }
       // 情况 3
       return left == null ? right : left;
   }
   ```

10. 完全二叉树的节点个数

    ```java
    public int countNodes(TreeNode root) {
        TreeNode l = root, r = root;
        // 记录左、右子树的高度
        int hl = 0, hr = 0;
        while (l != null) {
            l = l.left;
            hl++;
        }
        while (r != null) {
            r = r.right;
            hr++;
        }
        // 如果左右子树的高度相同，则是一棵满二叉树
        if (hl == hr) {
            return (int)Math.pow(2, hl) - 1;
        }
        // 如果左右高度不同，则按照普通二叉树的逻辑计算
        return 1 + countNodes(root.left) + countNodes(root.right);
    }
    ```

11. 非递归后序遍历

    ```c++
    class Solution {
    public:
        vector<int> postorderTraversal(TreeNode *root) {
            vector<int> res;
            if (root == nullptr) {
                return res;
            }
    
            stack<TreeNode *> stk;
            TreeNode *prev = nullptr;
            while (root != nullptr || !stk.empty()) {
                // 不断把左子节点入栈
                while (root != nullptr) {
                    stk.emplace(root);
                    root = root->left;
                }
                // 弹出栈顶
                root = stk.top();
                stk.pop();
                // 如果右子节点为空或者右子节点已经被遍历过，把根加入结果集
                if (root->right == nullptr || root->right == prev) {
                    res.emplace_back(root->val);
                    prev = root; // 记录遍历过的这个节点
                    root = nullptr;
                } else {
                    // 如果右子节点不空也没被遍历过，把此节点重新入栈，遍历它的右子节点
                    stk.emplace(root);
                    root = root->right;
                }
            }
            return res;
        }
    };
    ```

    

# 二叉搜索树BST

**BST 的中序遍历结果是有序的（升序）**。

## 技巧

1、如果当前节点会对下面的子节点有整体影响，可以通过辅助函数增长参数列表，借助参数传递信息。

2、在二叉树递归框架之上，扩展出一套 BST 代码框架：

```java
void BST(TreeNode root, int target) {
    if (root.val == target)
        // 找到目标，做点什么
    if (root.val < target) 
        BST(root.right, target);
    if (root.val > target)
        BST(root.left, target);
}
```

3、根据代码框架掌握了 BST 的增删查改操作。

1. 二叉搜索树中第k小的元素

   描述：给定一个二叉搜索树的根节点 `root` ，和一个整数 `k` ，请你设计一个算法查找其中第 `k` 个最小元素（从 1 开始计数）。

   思路：需要在二叉树节点中维护额外信息。**每个节点需要记录，以自己为根的这棵二叉树有多少个节点**。

   ```c++
   class Solution {
       int res = 0, rank = 0;
       void traverse(TreeNode* root, int k) {
           if (root == nullptr) {
               return;
           }
           traverse(root->left, k);
           ++rank;
           if (rank == k) {
               res = root->val;
               return;
           }
           traverse(root->right, k);
       }
   public:
       int kthSmallest(TreeNode* root, int k) {
           traverse(root, k);
           return res;
       }
   };
   ```

2. 把二叉搜索树转换为累加树

   描述：给出二叉 搜索 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 node 的新值等于原树中大于或等于 node.val 的值之和。

   思路：**利用 BST 的中序遍历特性**，把递归顺序改一下，**降序**打印节点的值。

   ```java
   TreeNode convertBST(TreeNode root) {
       traverse(root);
       return root;
   }
   
   // 记录累加和
   int sum = 0;
   void traverse(TreeNode root) {
       if (root == null) {
           return;
       }
       traverse(root.right);
       // 维护累加和
       sum += root.val;
       // 将 BST 转化成累加树
       root.val = sum;
       traverse(root.left);
   }
   ```

3. 验证二叉搜索树

   ```java
   boolean isValidBST(TreeNode root) {
       return isValidBST(root, null, null);
   }
   
   /* 限定以 root 为根的子树节点必须满足 max.val > root.val > min.val */
   boolean isValidBST(TreeNode root, TreeNode min, TreeNode max) {
       // base case
       if (root == null) return true;
       // 若 root.val 不符合 max 和 min 的限制，说明不是合法 BST
       if (min != null && root.val <= min.val) return false;
       if (max != null && root.val >= max.val) return false;
       // 限定左子树的最大值是 root.val，右子树的最小值是 root.val
       return isValidBST(root.left, min, root) 
           && isValidBST(root.right, root, max);
   }
   ```

4. 二叉搜索树中的搜索

   描述：给定二叉搜索树（BST）的根节点和一个值。 你需要在BST中找到节点值等于给定值的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 NULL。

   ```java
   boolean isInBST(TreeNode root, int target) {
       if (root == null) return false;
       if (root.val == target)
           return true;
       if (root.val < target) 
           return isInBST(root.right, target);
       if (root.val > target)
           return isInBST(root.left, target);
       // root 该做的事做完了，顺带把框架也完成了，妙
   }
   ```

5. 二傻搜索树中的插入操作

   给定二叉搜索树（BST）的根节点和要插入树中的值，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 保证 ，新值和原始二叉搜索树中的任意节点值都不同。

   注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回 任意有效的结果 。

   思路：对数据结构的操作无非遍历 + 访问，遍历就是「找」，访问就是「改」。具体到这个问题，插入一个数，就是先找到插入位置，然后进行插入操作。**一旦涉及「改」，函数就要返回** **`TreeNode`** **类型，并且对递归调用的返回值进行接收**。

   ```java
   TreeNode insertIntoBST(TreeNode root, int val) {
       // 找到空位置插入新节点
       if (root == null) return new TreeNode(val);
       // if (root.val == val)
       //     BST 中一般不会插入已存在元素
       if (root.val < val) 
           root.right = insertIntoBST(root.right, val);
       if (root.val > val) 
           root.left = insertIntoBST(root.left, val);
       return root;
   }
   ```

6. 删除二叉搜索树中的节点

   描述：给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。

   一般来说，删除节点可分为两个步骤：

   首先找到需要删除的节点；
   如果找到了，删除它。
   说明： 要求算法时间复杂度为 O(h)，h 为树的高度。

   思路：**情况 1**：`A` 恰好是末端节点，两个子节点都为空，那么它可以当场去世了。**情况 2**：`A` 只有一个非空子节点，那么它要让这个孩子接替自己的位置。**情况 3**：`A` 有两个子节点，麻烦了，为了不破坏 BST 的性质，`A` 必须找到左子树中最大的那个节点，或者右子树中最小的那个节点来接替自己。

   ![img](pic\011.jpg)

   ```java
   TreeNode deleteNode(TreeNode root, int key) {
       if (root == null) return null;
       if (root.val == key) {
           // 这两个 if 把情况 1 和 2 都正确处理了
           if (root.left == null) return root.right;
           if (root.right == null) return root.left;
           // 处理情况 3
           TreeNode minNode = getMin(root.right);
           root.val = minNode.val;
           root.right = deleteNode(root.right, minNode.val);
       } else if (root.val > key) {
           root.left = deleteNode(root.left, key);
       } else if (root.val < key) {
           root.right = deleteNode(root.right, key);
       }
       return root;
   }
   
   TreeNode getMin(TreeNode node) {
       // BST 最左边的就是最小的
       while (node.left != null) node = node.left;
       return node;
   }
   ```

# 二叉堆

```java
public class MaxPQ
    <Key extends Comparable<Key>> {
    // 存储元素的数组
    private Key[] pq;
    // 当前 Priority Queue 中的元素个数
    private int N = 0;

    public MaxPQ(int cap) {
        // 索引 0 不用，所以多分配一个空间
        pq = (Key[]) new Comparable[cap + 1];
    }

    /* 返回当前队列中最大元素 */
    public Key max() {
        return pq[1];
    }

    /* 插入元素 e */
    public void insert(Key e) {
        N++;
        // 先把新元素加到最后
        pq[N] = e;
        // 然后让它上浮到正确的位置
        swim(N);
    }

    /* 删除并返回当前队列中最大元素 */
    public Key delMax() {
        // 最大堆的堆顶就是最大元素
        Key max = pq[1];
        // 把这个最大元素换到最后，删除之
        exch(1, N);
        pq[N] = null;
        N--;
        // 让 pq[1] 下沉到正确位置
        sink(1);
        return max;
    }

    /* 上浮第 k 个元素，以维护最大堆性质 */
    private void swim(int k) {
        // 如果浮到堆顶，就不能再上浮了
        while (k > 1 && less(parent(k), k)) {
            // 如果第 k 个元素比上层大
            // 将 k 换上去
            exch(parent(k), k);
            k = parent(k);
        }
    }

    /* 下沉第 k 个元素，以维护最大堆性质 */
    private void sink(int k) {
        // 如果沉到堆底，就沉不下去了
        while (left(k) <= N) {
            // 先假设左边节点较大
            int older = left(k);
            // 如果右边节点存在，比一下大小
            if (right(k) <= N && less(older, right(k)))
                older = right(k);
            // 结点 k 比俩孩子都大，就不必下沉了
            if (less(older, k)) break;
            // 否则，不符合最大堆的结构，下沉 k 结点
            exch(k, older);
            k = older;
        }
    }

    /* 交换数组的两个元素 */
    private void exch(int i, int j) {
        Key temp = pq[i];
        pq[i] = pq[j];
        pq[j] = temp;
    }

    /* pq[i] 是否比 pq[j] 小？ */
    private boolean less(int i, int j) {
        return pq[i].compareTo(pq[j]) < 0;
    }

    /* 还有 left, right, parent 三个方法 */
}
```



# 链表

1. 反转链表

   ![img](pic\007.jpg)

   ```java
   ListNode successor = null; // 后驱节点
   
   // 反转以 head 为起点的 n 个节点，返回新的头结点
   ListNode reverseN(ListNode head, int n) {
       // 反转一个元素，就是它本身，同时要记录后驱节点
       if (n == 1) { 
           // 记录第 n + 1 个节点
           successor = head.next;
           return head;
       }
       // 以 head.next 为起点，需要反转前 n - 1 个节点
       ListNode last = reverseN(head.next, n - 1);
   
       head.next.next = head;
       // 让反转之后的 head 节点和后面的节点连起来
       head.next = successor;
       return last;
   }
   ListNode reverseBetween(ListNode head, int m, int n) {
       // base case
       if (m == 1) {
           return reverseN(head, n);
       }
       // 前进到反转的起点触发 base case
       head.next = reverseBetween(head.next, m - 1, n - 1);
       return head;
   }
   ```

2. K个一组翻转链表

   描述：给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。

   k 是一个正整数，它的值小于或等于链表的长度。

   如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。

   进阶：

   你可以设计一个只使用常数额外空间的算法来解决此问题吗？
   你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。

   思路：先翻转以head开头的k个元素，再将第k+1个元素作为head递归调用reverseKGroup(), 最后连起来

   ```java
   /** 反转区间 [a, b) 的元素，注意是左闭右开 */
   ListNode reverse(ListNode a, ListNode b) {
       ListNode pre, cur, nxt;
       pre = null; cur = a; nxt = a;
       // while 终止的条件改一下就行了
       while (cur != b) {
           nxt = cur.next;
           cur.next = pre;
           pre = cur;
           cur = nxt;
       }
       // 返回反转后的头结点
       return pre;
   }
   ListNode reverseKGroup(ListNode head, int k) {
       if (head == null) return null;
       // 区间 [a, b) 包含 k 个待反转元素
       ListNode a, b;
       a = b = head;
       for (int i = 0; i < k; i++) {
           // 不足 k 个，不需要反转，base case
           if (b == null) return head;
           b = b.next;
       }
       // 反转前 k 个元素
       ListNode newHead = reverse(a, b);
       // 递归反转后续链表并连接起来
       a.next = reverseKGroup(b, k);
       return newHead;
   }
   ```

3. 判断回文链表

   思路：先通过双指针技巧中的快慢指针来找到链表的中点。如果fast没指向null，说明长度为奇数，slow还要再前进一步。从slow开始反转后面的链表。开始比较。

   ```java
   ListNode reverse(ListNode head) {
       ListNode pre = null, cur = head;
       while (cur != null) {
           ListNode next = cur.next;
           cur.next = pre;
           pre = cur;
           cur = next;
       }
       return pre;
   }
   public boolean isPalindrome(ListNode head) {
   	ListNode slow, fast;
       slow = fast = head;
       while (fast != null && fast.next != null) {
           slow = slow.next;
           fast = fast.next.next;
       }
       // slow 指针现在指向链表中点
       if (fast != null)
       	slow = slow.next;
       ListNode left = head;
       ListNode right = reverse(slow);
   
       while (right != null) {
           if (left.val != right.val)
               return false;
           left = left.next;
           right = right.next;
       }
       return true;
   }
   ```


# 并查集

## 讲解

```java
class UF {
    /* 将 p 和 q 连接 */
    public void union(int p, int q);
    /* 判断 p 和 q 是否连通 */
    public boolean connected(int p, int q);
    /* 返回图中有多少个连通分量 */
    public int count();
}
```

这里所说的「连通」是一种等价关系，也就是说具有如下三个性质：

1、自反性：节点`p`和`p`是连通的。

2、对称性：如果节点`p`和`q`连通，那么`q`和`p`也连通。

3、传递性：如果节点`p`和`q`连通，`q`和`r`连通，那么`p`和`r`也连通。

构造函数初始化数据结构需要 O(N) 的时间和空间复杂度；连通两个节点`union`、判断两个节点的连通性`connected`、计算连通分量`count`所需的时间复杂度均为 O(1)。

```java
class UF {
    // 连通分量个数
    private int count;
    // 存储一棵树
    private int[] parent;
    // 记录树的“重量”
    private int[] size;

    public UF(int n) {
        this.count = n;
        parent = new int[n];
        size = new int[n];
        for (int i = 0; i < n; i++) {
            parent[i] = i;
            size[i] = 1;
        }
    }

    public void union(int p, int q) {
        int rootP = find(p);
        int rootQ = find(q);
        if (rootP == rootQ)
            return;

        // 小树接到大树下面，较平衡
        if (size[rootP] > size[rootQ]) {
            parent[rootQ] = rootP;
            size[rootP] += size[rootQ];
        } else {
            parent[rootP] = rootQ;
            size[rootQ] += size[rootP];
        }
        count--;
    }

    public boolean connected(int p, int q) {
        int rootP = find(p);
        int rootQ = find(q);
        return rootP == rootQ;
    }

    private int find(int x) {
        while (parent[x] != x) {
            // 进行路径压缩
            parent[x] = parent[parent[x]];
            x = parent[x];
        }
        return x;
    }

    public int count() {
        return count;
    }
}
```

调用`find`函数每次向树根遍历的同时，顺手将树高缩短了，最终所有树高都不会超过 3（`union`的时候树高可能达到 3）。

算法的关键点有 3 个：

1、用 `parent` 数组记录每个节点的父节点，相当于指向父节点的指针，所以 `parent` 数组内实际存储着一个森林（若干棵多叉树）。

2、用 `size` 数组记录着每棵树的重量，目的是让 `union` 后树依然拥有平衡性，而不会退化成链表，影响操作效率。

3、在 `find` 函数中进行路径压缩，保证任意树的高度保持在常数，使得 `union` 和 `connected` API 时间复杂度为 O(1)。

## 题目

1. 被围绕的区域

   描述：给你一个 `m x n` 的矩阵 `board` ，由若干字符 `'X'` 和 `'O'` ，找到所有被 `'X'` 围绕的区域，并将这些区域里所有的 `'O'` 用 `'X'` 填充。

   思路：

   传统方法：先用 for 循环遍历棋盘的**四边**，用 DFS 算法把那些与边界相连的 `O` 换成一个特殊字符，比如 `#`；然后再遍历整个棋盘，把剩下的 `O` 换成 `X`，把 `#` 恢复成 `O`。这样就能完成题目的要求，时间复杂度 O(MN)。

   并查集：**你可以把那些不需要被替换的** **`O`** **看成一个拥有独门绝技的门派，它们有一个共同祖师爷叫** **`dummy`**，这些 **`O`** **和** **`dummy`** **互相连通，而那些需要被替换的** **`O`** **与** **`dummy`** **不连通**。二维坐标 `(x,y)` 可以转换成 `x * n + y` 这个数（`m` 是棋盘的行数，`n` 是棋盘的列数）。让这个虚拟的 `dummy` 节点占据索引 `m * n`

   ```java
   void solve(char[][] board) {
       if (board.length == 0) return;
   
       int m = board.length;
       int n = board[0].length;
       // 给 dummy 留一个额外位置
       UF uf = new UF(m * n + 1);
       int dummy = m * n;
       // 将首列和末列的 O 与 dummy 连通
       for (int i = 0; i < m; i++) {
           if (board[i][0] == 'O')
               uf.union(i * n, dummy);
           if (board[i][n - 1] == 'O')
               uf.union(i * n + n - 1, dummy);
       }
       // 将首行和末行的 O 与 dummy 连通
       for (int j = 0; j < n; j++) {
           if (board[0][j] == 'O')
               uf.union(j, dummy);
           if (board[m - 1][j] == 'O')
               uf.union(n * (m - 1) + j, dummy);
       }
       // 方向数组 d 是上下左右搜索的常用手法
       int[][] d = new int[][]{{1,0}, {0,1}, {0,-1}, {-1,0}};
       for (int i = 1; i < m - 1; i++) 
           for (int j = 1; j < n - 1; j++) 
               if (board[i][j] == 'O')
                   // 将此 O 与上下左右的 O 连通
                   for (int k = 0; k < 4; k++) {
                       int x = i + d[k][0];
                       int y = j + d[k][1];
                       if (board[x][y] == 'O')
                           uf.union(x * n + y, i * n + j);
                   }
       // 所有不和 dummy 连通的 O，都要被替换
       for (int i = 1; i < m - 1; i++) 
           for (int j = 1; j < n - 1; j++) 
               if (!uf.connected(dummy, i * n + j))
                   board[i][j] = 'X';
   }
   ```

2. 等式方程的可满足性

   描述：给定一个由表示变量之间关系的字符串方程组成的数组，每个字符串方程 equations[i] 的长度为 4，并采用两种不同的形式之一："a==b" 或 "a!=b"。在这里，a 和 b 是小写字母（不一定不同），表示单字母变量名。

   只有当可以将整数分配给变量名，以便满足所有给定的方程时才返回 true，否则返回 false。 

   思路：**将** **`equations`** **中的算式根据** **`==`** **和** **`!=`** **分成两部分，先处理** **`==`** **算式，使得他们通过相等关系各自勾结成门派；然后处理** **`!=`** **算式，检查不等关系是否破坏了相等关系的连通性**。

   ```java
   boolean equationsPossible(String[] equations) {
       // 26 个英文字母
       UF uf = new UF(26);
       // 先让相等的字母形成连通分量
       for (String eq : equations) {
           if (eq.charAt(1) == '=') {
               char x = eq.charAt(0);
               char y = eq.charAt(3);
               uf.union(x - 'a', y - 'a');
           }
       }
       // 检查不等关系是否打破相等关系的连通性
       for (String eq : equations) {
           if (eq.charAt(1) == '!') {
               char x = eq.charAt(0);
               char y = eq.charAt(3);
               // 如果相等关系成立，就是逻辑冲突
               if (uf.connected(x - 'a', y - 'a'))
                   return false;
           }
       }
       return true;
   }
   ```

# 单调栈

单调栈实际上就是栈，只是利用了一些巧妙的逻辑，使得每次新元素入栈后，栈内的元素都保持有序（单调递增或单调递减）。

把数组的元素想象成并列站立的人，元素大小想象成人的身高。这些人面对你站成一列，如何求元素「2」的 Next Greater Number 呢？很简单，如果能够看到元素「2」，那么他后面可见的第一个人就是「2」的 Next Greater Number，因为比「2」小的元素身高不够，都被「2」挡住了，第一个露出来的就是答案。

模板：

```c++
vector<int> nextGreaterElement(vector<int>& nums) {
    vector<int> res(nums.size()); // 存放答案的数组
    stack<int> s;
    // 倒着往栈里放
    for (int i = nums.size() - 1; i >= 0; i--) {
        // 判定个子高矮
        while (!s.empty() && s.top() <= nums[i]) {
            // 矮个起开，反正也被挡着了。。。
            s.pop();
        }
        // nums[i] 身后的 next great number
        res[i] = s.empty() ? -1 : s.top();
        // 
        s.push(nums[i]);
    }
    return res;
}
```

1. 下一个更大元素1

   描述：给你两个 没有重复元素 的数组 nums1 和 nums2 ，其中nums1 是 nums2 的子集。请你找出 nums1 中每个元素在 nums2 中的下一个比其大的值。nums1 中数字 x 的下一个更大元素是指 x 在 nums2 中对应位置的右边的第一个比 x 大的元素。如果不存在，对应位置输出 -1 。

   思路：

   可以发现，我们维护的栈恰好保证了单调性：栈中的元素从栈顶到栈底是单调不降的。当我们遇到一个新的元素 nums2[i] 时，我们判断栈顶元素是否小于 nums2[i]，如果是，那么栈顶元素的下一个更大元素即为 nums2[i]，我们将栈顶元素出栈。重复这一操作，直到栈为空或者栈顶元素大于 nums2[i]。此时我们将 nums2[i] 入栈，保持栈的单调性，并对接下来的 nums2[i + 1], nums2[i + 2] ... 执行同样的操作。

   ```java
   import java.util.ArrayDeque;
   import java.util.Arrays;
   import java.util.Deque;
   import java.util.HashMap;
   import java.util.Map;
   import java.util.Stack;
   
   public class Solution {
   
       public int[] nextGreaterElement(int[] nums1, int[] nums2) {
           int len1 = nums1.length;
           int len2 = nums2.length;
   
           Deque<Integer> stack = new ArrayDeque<>();
           Map<Integer, Integer> map = new HashMap<>();
           // 先处理 nums2，把对应关系存入哈希表
           for (int i = 0; i < len2; i++) {
               while (!stack.isEmpty() && stack.peekLast() < nums2[i]) {
                   map.put(stack.removeLast(), nums2[i]);
               }
               stack.addLast(nums2[i]);
           }
   
           // 遍历 nums1 得到结果集
           int[] res = new int[len1];
           for (int i = 0; i < len1; i++) {
               res[i] = map.getOrDefault(nums1[i], -1);
           }
           return res;
       }
   }
   ```

2. 每日温度

   描述：请根据每日 气温 列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用 0 来代替。

   例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。

   提示：气温 列表长度的范围是 [1, 30000]。每个气温的值的均为华氏度，都是在 [30, 100] 范围内的整数。

   ```c++
   vector<int> dailyTemperatures(vector<int>& T) {
       vector<int> res(T.size());
       // 这里放元素索引，而不是元素
       stack<int> s; 
       /* 单调栈模板 */
       for (int i = T.size() - 1; i >= 0; i--) {
           while (!s.empty() && T[s.top()] <= T[i]) {
               s.pop();
           }
           // 得到索引间距
           res[i] = s.empty() ? 0 : (s.top() - i); 
           // 将索引入栈，而不是元素
           s.push(i); 
       }
       return res;
   }
   ```

3. 下一个更大元素2

   描述：给定一个循环数组（最后一个元素的下一个元素是数组的第一个元素），输出每个元素的下一个更大元素。数字 x 的下一个更大的元素是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 -1。

   思路：**对于这种需求，常用套路就是将数组长度翻倍**：**利用循环数组的技巧来模拟数组长度翻倍的效果**。

   ```c++
   vector<int> nextGreaterElements(vector<int>& nums) {
       int n = nums.size();
       vector<int> res(n);
       stack<int> s;
       // 假装这个数组长度翻倍了
       for (int i = 2 * n - 1; i >= 0; i--) {
           // 索引要求模，其他的和模板一样
           while (!s.empty() && s.top() <= nums[i % n])
               s.pop();
           res[i % n] = s.empty() ? -1 : s.top();
           s.push(nums[i % n]);
       }
       return res;
   }
   ```

   

# 双指针

1. 环形链表1

   给定一个链表，判断链表中是否有环。

   如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。

   如果链表中存在环，则返回 true 。 否则，返回 false 。

   ```java
   boolean hasCycle(ListNode head) {
       ListNode fast, slow;
       fast = slow = head;
       while (fast != null && fast.next != null) {
           fast = fast.next.next;
           slow = slow.next;
   
           if (fast == slow) return true;
       }
       return false;
   }
   ```

2. 环形链表2

   描述：给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。

   为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意，pos 仅仅是用于标识环的情况，并不会作为参数传递到函数中。

   说明：不允许修改给定的链表。

   进阶：

   你是否可以使用 O(1) 空间解决此题？

   ```java
   ListNode detectCycle(ListNode head) {
       ListNode fast, slow;
       fast = slow = head;
       while (fast != null && fast.next != null) {
           fast = fast.next.next;
           slow = slow.next;
           if (fast == slow) break;
       }
       // 上面的代码类似 hasCycle 函数
       if (fast == null || fast.next == null) {
           // fast 遇到空指针说明没有环
           return null;
       }
   
       slow = head;
       while (slow != fast) {
           fast = fast.next;
           slow = slow.next;
       }
       return slow;
   }
   ```

3. 链表的中间节点

   描述：给定一个头结点为 `head` 的非空单链表，返回链表的中间结点。

   如果有两个中间结点，则返回第二个中间结点。

   ```java
   ListNode middleNode(ListNode head) {
       ListNode fast, slow;
       fast = slow = head;
       while (fast != null && fast.next != null) {
           fast = fast.next.next;
           slow = slow.next;
       }
       // slow 就在中间位置
       return slow;
   }
   ```

4. 寻找链表的倒数第n个元素

   给你一个链表，删除链表的倒数第 `n` 个结点，并且返回链表的头结点。

   **进阶：**你能尝试使用一趟扫描实现吗？

   ```java
   ListNode removeNthFromEnd(ListNode head, int n) {
       ListNode fast, slow;
       fast = slow = head;
       // 快指针先前进 n 步
       while (n-- > 0) {
           fast = fast.next;
       }
       if (fast == null) {
           // 如果此时快指针走到头了，
           // 说明倒数第 n 个节点就是第一个节点
           return head.next;
       }
       // 让慢指针和快指针同步向前
       while (fast != null && fast.next != null) {
           fast = fast.next;
           slow = slow.next;
       }
       // slow.next 就是倒数第 n 个节点，删除它
       slow.next = slow.next.next;
       return head;
   }
   ```

5. 两数之和2-输入有序数组

   描述：给定一个已按照 升序排列  的整数数组 numbers ，请你从数组中找出两个数满足相加之和等于目标数 target 。

   函数应该以长度为 2 的整数数组的形式返回这两个数的下标值。numbers 的下标 从 1 开始计数 ，所以答案数组应当满足 1 <= answer[0] < answer[1] <= numbers.length 。

   你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。

   ```java
   int[] twoSum(int[] nums, int target) {
       int left = 0, right = nums.length - 1;
       while (left < right) {
           int sum = nums[left] + nums[right];
           if (sum == target) {
               // 题目要求的索引是从 1 开始的
               return new int[]{left + 1, right + 1};
           } else if (sum < target) {
               left++; // 让 sum 大一点
           } else if (sum > target) {
               right--; // 让 sum 小一点
           }
       }
       return new int[]{-1, -1};
   }
   ```

6. 反转字符串

   描述：编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。

   不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。

   你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。

   ```java
   void reverseString(char[] arr) {
       int left = 0;
       int right = arr.length - 1;
       while (left < right) {
           // 交换 arr[left] 和 arr[right]
           char temp = arr[left];
           arr[left] = arr[right];
           arr[right] = temp;
           left++; right--;
       }
   }
   ```

# 删除/查找数组元素

1. 常数时间插入、删除和获取随机元素

   描述：设计一个支持在平均 时间复杂度 O(1) 下，执行以下操作的数据结构。

   insert(val)：当元素 val 不存在时，向集合中插入该项。
   remove(val)：元素 val 存在时，从集合中移除该项。
   getRandom：随机返回现有集合中的一项。每个元素应该有相同的概率被返回。

   思路：根据上面的分析，对于 `getRandom` 方法，如果想「等概率」且「在 O(1) 的时间」取出元素，一定要满足：**底层用数组实现，且数组必须是紧凑的**。

   这样我们就可以直接生成随机数作为索引，从数组中取出该随机索引对应的元素，作为随机元素。

   **但如果用数组存储元素的话，插入，删除的时间复杂度怎么可能是 O(1) 呢**？

   可以做到！对数组尾部进行插入和删除操作不会涉及数据搬移，时间复杂度是 O(1)。

   **所以，如果我们想在 O(1) 的时间删除数组中的某一个元素** **`val`**，可以先把这个元素交换到数组的尾部，然后再 **`pop`** **掉**。

   交换两个元素必须通过索引进行交换对吧，那么我们需要一个哈希表 `valToIndex` 来记录每个元素值对应的索引。

   ```c++
   class RandomizedSet {
   public:
       // 存储元素的值
       vector<int> nums;
       // 记录每个元素对应在 nums 中的索引
       unordered_map<int,int> valToIndex;
   
       bool insert(int val) {
           // 若 val 已存在，不用再插入
           if (valToIndex.count(val)) {
               return false;
           }
           // 若 val 不存在，插入到 nums 尾部，
           // 并记录 val 对应的索引值
           valToIndex[val] = nums.size();
           nums.push_back(val);
           return true;
       }
   
       bool remove(int val) {
           // 若 val 不存在，不用再删除
           if (!valToIndex.count(val)) {
               return false;
           }
           // 先拿到 val 的索引
           int index = valToIndex[val];
           // 将最后一个元素对应的索引修改为 index
           valToIndex[nums.back()] = index;
           // 交换 val 和最后一个元素
           swap(nums[index], nums.back());
           // 在数组中删除元素 val
           nums.pop_back();
           // 删除元素 val 对应的索引
           valToIndex.erase(val);
           return true;
       }
   
       int getRandom() {
           // 随机获取 nums 中的一个元素
           return nums[rand() % nums.size()];
       }
   };
   ```

2. 黑名单中的随机数

   描述：给定一个包含 [0，n ) 中独特的整数的黑名单 B，写一个函数从 [ 0，n ) 中返回一个不在 B 中的随机整数。

   对它进行优化使其尽量少调用系统方法 Math.random() 。

   思路：**将区间** **`[0,N)`** **看做一个数组，然后将** **`blacklist`** **中的元素移到数组的最末尾，同时用一个哈希表进行映射**：

   1、如果想高效地，等概率地随机获取元素，就要使用数组作为底层容器。

   2、如果要保持数组元素的紧凑性，可以把待删除元素换到最后，然后 `pop` 掉末尾的元素，这样时间复杂度就是 O(1) 了。当然，我们需要额外的哈希表记录值到索引的映射。

   3、对于第二题，数组中含有「空洞」（黑名单数字），也可以利用哈希表巧妙处理映射关系，让数组在逻辑上是紧凑的，方便随机取元素。

   ```c++
   class Solution {
   public:
       int sz;
       unordered_map<int, int> mapping;
   
       Solution(int N, vector<int>& blacklist) {
           sz = N - blacklist.size();
           for (int b : blacklist) {
               mapping[b] = 666;
           }
   
           int last = N - 1;
           for (int b : blacklist) {
               // 如果 b 已经在区间 [sz, N)
               // 可以直接忽略
               if (b >= sz) {
                   continue;
               }
               while (mapping.count(last)) {
                   last--;
               }
               mapping[b] = last;
               last--;
           }
       }
   
       int pick() {
           // 随机选取一个索引
           int index = rand() % sz;
           // 这个索引命中了黑名单，
           // 需要被映射到其他位置
           if (mapping.count(index)) {
               return mapping[index];
           }
           // 若没命中黑名单，则直接返回
           return index;
       }
   };
   ```

   

# 原地修改数组

1. 删除有序数组中的重复项

   描述：给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。

   不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。

   ```java
   int removeDuplicates(int[] nums) {
       if (nums.length == 0) {
           return 0;
       }
       int slow = 0, fast = 0;
       while (fast < nums.length) {
           if (nums[fast] != nums[slow]) {
               slow++;
               // 维护 nums[0..slow] 无重复
               nums[slow] = nums[fast];
           }
           fast++;
       }
       // 数组长度为索引 + 1
       return slow + 1;
   }
   ```

2. 删除排序链表中的重复元素

   ```java
   ListNode deleteDuplicates(ListNode head) {
       if (head == null) return null;
       ListNode slow = head, fast = head;
       while (fast != null) {
           if (fast.val != slow.val) {
               // nums[slow] = nums[fast];
               slow.next = fast;
               // slow++;
               slow = slow.next;
           }
           // fast++
           fast = fast.next;
       }
       // 断开与后面重复元素的连接
       slow.next = null;
       return head;
   }
   ```

3. 移除元素

   描述：给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。

   不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。

   元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。

   ```java
   int removeElement(int[] nums, int val) {
       int fast = 0, slow = 0;
       while (fast < nums.length) {
           if (nums[fast] != val) {
               nums[slow] = nums[fast];
               slow++;
           }
           fast++;
       }
       return slow;
   }
   ```

4. 移动0

   描述：给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。

   ```java
   void moveZeroes(int[] nums) {
       // 去除 nums 中的所有 0
       // 返回去除 0 之后的数组长度
       int p = removeElement(nums, 0); // 上一题
       // 将 p 之后的所有元素赋值为 0
       for (; p < nums.length; p++) {
           nums[p] = 0;
       }
   }
   
   // 见上文代码实现
   int removeElement(int[] nums, int val);
   ```

   

# 其他题目

## 数据流的中位数

描述：中位数是有序列表中间的数。如果列表长度是偶数，中位数则是中间两个数的平均值。

例如，

[2,3,4] 的中位数是 3

[2,3] 的中位数是 (2 + 3) / 2 = 2.5

设计一个支持以下两种操作的数据结构：

void addNum(int num) - 从数据流中添加一个整数到数据结构中。
double findMedian() - 返回目前所有元素的中位数。

思路：**使用两个优先级队列**。把「有序数组」抽象成一个倒三角形，宽度可以视为元素的大小，那么这个倒三角的中部就是计算中位数的元素。然后把这个大的倒三角形从正中间切成两半，变成一个小倒三角和一个梯形，这个小倒三角形相当于一个从小到大的有序数组，这个梯形相当于一个从大到小的有序数组。

![Image](pic\008.jpg)

中位数就可以通过小倒三角和梯形顶部的元素算出来。嗯，你联想到什么了没有？它们能不能用优先级队列表示？**小倒三角不就是个大顶堆嘛，梯形不就是个小顶堆嘛，中位数可以通过它们的堆顶元素算出来**。梯形虽然是小顶堆，但其中的元素是较大的，我们称其为`large`，倒三角虽然是大顶堆，但是其中元素较小，我们称其为`small`。两个堆中的元素之差不能超过 1。

设元素总数是`n`，如果`n`是偶数，我们希望两个堆的元素个数是一样的，这样把两个堆的堆顶元素拿出来求个平均数就是中位数；如果`n`是奇数，那么我们希望两个堆的元素个数分别是`n/2 + 1`和`n/2`，这样元素多的那个堆的堆顶元素就是中位数。**不仅要维护`large`和`small`的元素个数之差不超过 1，还要维护`large`堆的堆顶元素要大于等于`small`堆的堆顶元素**。**想要往`large`里添加元素，不能直接添加，而是要先往`small`里添加，然后再把`small`的堆顶元素加到`large`中；向`small`中添加元素同理**。

```java
class MedianFinder {

    private PriorityQueue<Integer> large;
    private PriorityQueue<Integer> small;

    public MedianFinder() {
        // 小顶堆
        large = new PriorityQueue<>();
        // 大顶堆
        small = new PriorityQueue<>((a, b) -> {
            return b - a;
        });
    }

    public double findMedian() {
        // 如果元素不一样多，多的那个堆的堆顶元素就是中位数
        if (large.size() < small.size()) {
            return small.peek();
        } else if (large.size() > small.size()) {
            return large.peek();
        }
        // 如果元素一样多，两个堆堆顶元素的平均数是中位数
        return (large.peek() + small.peek()) / 2.0;
    }

    public void addNum(int num) {
        if (small.size() >= large.size()) {
            small.offer(num);
            large.offer(small.poll());
        } else {
            large.offer(num);
            small.offer(large.poll());
        }
    }
}
```

```c++
//升序队列 小顶堆
priority_queue <int,vector<int>,greater<int> > q;
//降序队列 对于基础类型 默认是大顶堆
priority_queue <int,vector<int>,less<int> >q;

//greater和less是std实现的两个仿函数（就是使一个类的使用看上去像一个函数。其实现就是类中实现一个operator()，这个类就有了类似函数的行为，就是一个仿函数类了）
```

## 随机算法之水塘抽样算法

给一个未知长度的序列，如何在其中随机地选择`k`个元素

1. 链表随机节点

   描述：给定一个单链表，随机选择链表的一个节点，并返回相应的节点值。保证每个节点被选的概率一样。

   进阶:
   如果链表十分大且长度未知，如何解决这个问题？你能否使用常数级空间复杂度实现？

   思路：**当你遇到第`i`个元素时，应该有`1/i`的概率选择该元素，`1 - 1/i`的概率保持原有的选择**。

   ![Image](pic\009.jpg)

   第`i`个元素被选择的概率是`1/i`，第`i+1`次不被替换的概率是`1 - 1/(i+1)`，以此类推，相乘就是第`i`个元素最终被选中的概率，就是`1/n`。

   ```java
   /* 返回链表中一个随机节点的值 */
   int getRandom(ListNode head) {
       Random r = new Random();
       int i = 0, res = 0;
       ListNode p = head;
       // while 循环遍历链表
       while (p != null) {
           // 生成一个 [0, i) 之间的整数
           // 这个整数等于 0 的概率就是 1/i
           if (r.nextInt(++i) == 0) {
               res = p.val;
           }
           p = p.next;
       }
       return res;
   }
   /*同理，如果要随机选择k个数，只要在第i个元素处以k/i的概率选择该元素，以1 - k/i的概率保持原有选择即可*/
   /* 返回链表中 k 个随机节点的值 */
   int[] getRandom(ListNode head, int k) {
       Random r = new Random();
       int[] res = new int[k];
       ListNode p = head;
   
       // 前 k 个元素先默认选上
       for (int j = 0; j < k && p != null; j++) {
           res[j] = p.val;
           p = p.next;
       }
   
       int i = k;
       // while 循环遍历链表
       while (p != null) {
           // 生成一个 [0, i) 之间的整数
           int j = r.nextInt(++i);
           // 这个整数小于 k 的概率就是 k/i
           if (j < k) {
               res[j] = p.val;
           }
           p = p.next;
       }
       return res;
   }
   ```

   ![Image](pic\010.jpg)

   因为虽然每次更新选择的概率增大了`k`倍，但是选到具体第`i`个元素的概率还是要乘`1/k`，也就回到了上一个推导。

## 小白鼠试毒药

描述：1000瓶水其中有一瓶水有毒，有10只老鼠并且只要老鼠喝了有毒的水必死。请问怎样通过一次实验找出有毒的那瓶水。

思路：此题考察的是二进制。2的10次方等于1024，1024以内的所有自然数都可以用10个数位的二进制数表示出来。1000 <= 1024

第一步：将1000瓶水从water[0]到water[999]分别进行编号，并转化成10个数位的二进制数。

第二步：将10只老鼠从mouse[0]到mouse[9]进行编号，让第mouse[i]只老鼠喝第i位为1的所有的水，这样就保证了（除了第0瓶水外）每一瓶水都有老鼠喝了。 

第三步：根据老鼠的存活情况判定有毒水方法：

if(如果第i只老鼠死了) 则让 water[第i位1的水的编号]的值-1. 

else 则让 water[第i位1的水的编号]的值+1.  

​	然后找出wanrer[0]--water[999] 中 的最小数water[i]，  

if(water[i] <0) 即为 第 i 瓶水有毒    else 为第0瓶水有毒。 

    原因：因为water[0]--water[999]的初始值都为0，如果第i只老鼠死了，说明第mouse[i]只老鼠喝的水中必有一瓶有毒,所以令 water[第i位1的水的编号]的值各-1.如果第i只老鼠没有死，说明第mouse[i]只老鼠喝的水都没有毒,所以令 water[第i位1的水的编号]的值各+1。

```java
import java.util.Arrays;
import java.lang.StringBuilder;
import java.util.Scanner;
 
public class toxicWater {
	public static final int waterNumber = 1000;//水的数目
	public static final int mouseNumber = 10;//老鼠的数目
	
	public static void main(String args[]){
		int water[] = new int[waterNumber];
		int mouse[] = new int[mouseNumber];
		int i,j;
		String s;
		StringBuffer sb;
		int flag = 1;
		
		Scanner reader = new Scanner(System.in);
//		System.out.println("请输入老鼠的存活情况，1 表示死了，0表示还活着：");
		for( i=0; i<mouseNumber; i++){
			System.out.println("请输入第"+i+"老鼠的存活情况(1 表示死了，0表示还活着)");
			mouse[i] = reader.nextInt();
		}
		for( i=0; i<mouseNumber; i++ ){//mouseNumber只老鼠
			for( j=0; j<waterNumber; j++ ){//1000瓶水
				s = Long.toBinaryString(j);//将 j 转换为二进制
				sb = new StringBuffer(s);
				sb.reverse();//将字符串反转
				if( sb.length() >= i+1 ){//字符串长度
					if( mouse[i] == 1 ){//老鼠死了
						if( sb.charAt(i) == '1'){//第i只老鼠喝了第j瓶水
							water[j]--;
						}
					}
					else{//老鼠未死
						if( sb.charAt(i) == '1'){
							water[j]++;
						}
					}
				}
			}
		}
		int min = 0;
		for( i=0; i<waterNumber; i++ ){//找出数值最小的water
			if( water[i] < min ){
				min = water[i];
				flag = i;
			}
		}
		if( min < 0 ){
			System.out.println("第瓶"+flag+"瓶水有毒!!!");
		}
		else{
			System.out.println("第瓶0瓶水有毒!!!");
		}
	}
}
```

## 扁平化嵌套列表迭代器

描述：给你一个嵌套的整型列表。请你设计一个迭代器，使其能够遍历这个整型列表中的所有整数。

列表中的每一项或者为一个整数，或者是另一个列表。其中列表的元素也可能是整数或是其他列表。

思路：**调用`hasNext`时，如果`nestedList`的第一个元素是列表类型，则不断展开这个元素，直到第一个元素是整数类型**。

由于调用`next`方法之前一定会调用`hasNext`方法，这就可以保证每次调用`next`方法的时候第一个元素是整数型，直接返回并删除第一个元素即可。

```java
public class NestedIterator implements Iterator<Integer> {
    private LinkedList<NestedInteger> list;

    public NestedIterator(List<NestedInteger> nestedList) {
        // 不直接用 nestedList 的引用，是因为不能确定它的底层实现
        // 必须保证是 LinkedList，否则下面的 addFirst 会很低效
        list = new LinkedList<>(nestedList);
    }

    public Integer next() {
        // hasNext 方法保证了第一个元素一定是整数类型
        return list.remove(0).getInteger();
    }

    public boolean hasNext() {
        // 循环拆分列表元素，直到列表第一个元素是整数类型
        while (!list.isEmpty() && !list.get(0).isInteger()) {
            // 当列表开头第一个元素是列表类型时，进入循环
            List<NestedInteger> first = list.remove(0).getList();
            // 将第一个列表打平并按顺序添加到开头
            for (int i = first.size() - 1; i >= 0; i--) {
                list.addFirst(first.get(i));
            }
        }
        return !list.isEmpty();
    }
}
```

```c++
/**
 * // This is the interface that allows for creating nested lists.
 * // You should not implement it, or speculate about its implementation
 * class NestedInteger {
 *   public:
 *     // Return true if this NestedInteger holds a single integer, rather than a nested list.
 *     bool isInteger() const;
 *
 *     // Return the single integer that this NestedInteger holds, if it holds a single integer
 *     // The result is undefined if this NestedInteger holds a nested list
 *     int getInteger() const;
 *
 *     // Return the nested list that this NestedInteger holds, if it holds a nested list
 *     // The result is undefined if this NestedInteger holds a single integer
 *     const vector<NestedInteger> &getList() const;
 * };
 */

class NestedIterator {
    // pair 中存储的是列表的当前遍历位置，以及一个尾后迭代器用于判断是否遍历到了列表末尾
    stack<pair<vector<NestedInteger>::iterator, vector<NestedInteger>::iterator>> stk;
public:
    NestedIterator(vector<NestedInteger> &nestedList) {
        stk.emplace(nestedList.begin(), nestedList.end());
    }
    
    int next() {
        // 由于保证调用 next 之前会调用 hasNext，直接返回栈顶列表的当前元素，然后迭代器指向下一个元素
        return stk.top().first++->getInteger();
    }
    
    bool hasNext() {
        while (!stk.empty()) {
            auto &p = stk.top();
            if (p.first == p.second) { // 遍历到当前列表末尾，出栈
                stk.pop();
                continue;
            }
            if (p.first->isInteger()) {
                return true;
            }
            // 若当前元素为列表，则将其入栈，且迭代器指向下一个元素
            auto &lst = p.first++->getList();
            stk.emplace(lst.begin(), lst.end());
        }
        return false;
    }
};
```

## 缓存淘汰

1. LRU缓存机制(最近最少使用)

   描述：运用你所掌握的数据结构，设计和实现一个  LRU (最近最少使用) 缓存机制 。
   实现 LRUCache 类：

   LRUCache(int capacity) 以正整数作为容量 capacity 初始化 LRU 缓存
   int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。
   void put(int key, int value) 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字-值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。


   进阶：你是否可以在 O(1) 时间复杂度内完成这两种操作？

   条件：

   1、显然 `cache` 中的元素必须有时序，以区分最近使用的和久未使用的数据，当容量满了之后要删除最久未使用的那个元素腾位置。

   2、我们要在 `cache` 中快速找某个 `key` 是否已存在并得到对应的 `val`；

   3、每次访问 `cache` 中的某个 `key`，需要将这个元素变为最近使用的，也就是说 `cache` 要支持在任意位置快速插入和删除元素。

   那么，什么数据结构同时符合上述条件呢？哈希表查找快，但是数据无固定顺序；链表有顺序之分，插入删除快，但是查找慢。所以结合一下，形成一种新的数据结构：哈希链表 `LinkedHashMap`。

   LRU 缓存算法的核心数据结构就是哈希链表，双向链表和哈希表的结合体。

   ![img](pic\012.jpg)

   1、如果我们每次默认从链表尾部添加元素，那么显然越靠尾部的元素就是最近使用的，越靠头部的元素就是最久未使用的。

   2、对于某一个 `key`，我们可以通过哈希表快速定位到链表中的节点，从而取得对应 `val`。

   3、链表显然是支持在任意位置快速插入和删除的，改改指针就行。只不过传统的链表无法按照索引快速访问某一个位置的元素，而这里借助哈希表，可以通过 `key` 快速映射到任意一个链表节点，然后进行插入和删除。

   LRU 算法的核心数据结构是使用哈希链表 `LinkedHashMap`，首先借助链表的有序性使得链表元素维持插入顺序，同时借助哈希映射的快速访问能力使得我们可以在 O(1) 时间访问链表的任意元素。

   ```java
   class LRUCache {
       int cap;
       LinkedHashMap<Integer, Integer> cache = new LinkedHashMap<>();
       public LRUCache(int capacity) { 
           this.cap = capacity;
       }
   
       public int get(int key) {
           if (!cache.containsKey(key)) {
               return -1;
           }
           // 将 key 变为最近使用
           makeRecently(key);
           return cache.get(key);
       }
   
       public void put(int key, int val) {
           if (cache.containsKey(key)) {
               // 修改 key 的值
               cache.put(key, val);
               // 将 key 变为最近使用
               makeRecently(key);
               return;
           }
   
           if (cache.size() >= this.cap) {
               // 链表头部就是最久未使用的 key
               int oldestKey = cache.keySet().iterator().next();
               cache.remove(oldestKey);
           }
           // 将新的 key 添加链表尾部
           cache.put(key, val);
       }
   
       private void makeRecently(int key) {
           int val = cache.get(key);
           // 删除 key，重新插入到队尾
           cache.remove(key);
           cache.put(key, val);
       }
   }
   ```

   ```c++
   // 设计一个双向链表,链表中值为key-value映射
   struct DLinkedNode {
       int key, value;
       DLinkedNode* prev;
       DLinkedNode* next;
       DLinkedNode(): key(0), value(0), prev(nullptr), next(nullptr) {}
       DLinkedNode(int _key, int _value): key(_key), value(_value), prev(nullptr), next(nullptr) {}
   };
   
   class LRUCache {
   private:
       // 一个cache代表每个key对应链表节点的映射，方便寻找节点避免遍历链表
       unordered_map<int, DLinkedNode*> cache;
       // 最常用的cache放在表头，不常用的放表尾。超出容量以后，删除表尾的节点
       DLinkedNode* head;
       DLinkedNode* tail;
       // 当前的元素个数和总容量
       int size;
       int capacity;
   public:
       // 初始化一个缓存
       LRUCache(int _capacity): capacity(_capacity), size(0) {
           // 使用伪头部和伪尾部节点
           head = new DLinkedNode();
           tail = new DLinkedNode();
           head->next = tail;
           tail->prev = head;
       }
       int get(int key) {
           if (!cache.count(key)) {
               return -1;
           }
           // 如果 key 存在，先通过哈希表定位，再移到头部
           DLinkedNode* node = cache[key];
           // 最常用的放最前面
           moveToHead(node);
           return node->value;
       }
       void put(int key, int value) {
           if (!cache.count(key)) {
               // 如果 key 不存在，创建一个新的节点
               DLinkedNode* node = new DLinkedNode(key, value);
               // 添加进哈希表
               cache[key] = node;
               // 添加至双向链表的头部
               addToHead(node);
               ++size;
               if (size > capacity) {
                   // 如果超出容量，删除双向链表的尾部节点
                   DLinkedNode* removed = removeTail();
                   // 删除哈希表中对应的项
                   cache.erase(removed->key);
                   // 防止内存泄漏
                   delete removed;
                   --size;
               }
           }
           else {
               // 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部
               DLinkedNode* node = cache[key];
               node->value = value;
               moveToHead(node);
           }
       }
       void addToHead(DLinkedNode* node) {
           node->prev = head;
           node->next = head->next;
           head->next->prev = node;
           head->next = node;
       }
       
       void removeNode(DLinkedNode* node) {
           node->prev->next = node->next;
           node->next->prev = node->prev;
       }
   
       void moveToHead(DLinkedNode* node) {
           removeNode(node);
           addToHead(node);
       }
   
       DLinkedNode* removeTail() {
           DLinkedNode* node = tail->prev;
           removeNode(node);
           return node;
       }
   };
   ```

2. LFU缓存(最不经常使用)

   描述：请你为 最不经常使用（LFU）缓存算法设计并实现数据结构。

   实现 LFUCache 类：

   LFUCache(int capacity) - 用数据结构的容量 capacity 初始化对象
   int get(int key) - 如果键存在于缓存中，则获取键的值，否则返回 -1。
   void put(int key, int value) - 如果键已存在，则变更其值；如果键不存在，请插入键值对。当缓存达到其容量时，则应该在插入新项之前，使最不经常使用的项无效。在此问题中，当存在平局（即两个或更多个键具有相同使用频率）时，应该去除 最久未使用 的键。
   注意「项的使用次数」就是自插入该项以来对其调用 get 和 put 函数的次数之和。使用次数会在对应项被移除后置为 0 。

   为了确定最不常使用的键，可以为缓存中的每个键维护一个 使用计数器 。使用计数最小的键是最久未使用的键。

   当一个键首次插入到缓存中时，它的使用计数器被设置为 1 (由于 put 操作)。对缓存中的键执行 get 或 put 操作，使用计数器的值将会递增。

   思路：

   1、调用 `get(key)` 方法时，要返回该 `key` 对应的 `val`。

   2、只要用 `get` 或者 `put` 方法访问一次某个 `key`，该 `key` 的 `freq` 就要加一。

   3、如果在容量满了的时候进行插入，则需要将 `freq` 最小的 `key` 删除，如果最小的 `freq` 对应多个 `key`，则删除其中最旧的那一个。

   1、使用一个 `HashMap` 存储 `key` 到 `val` 的映射，就可以快速计算 `get(key)`。

   ```
   HashMap<Integer, Integer> keyToVal;
   ```

   2、使用一个 `HashMap` 存储 `key` 到 `freq` 的映射，就可以快速操作 `key` 对应的 `freq`。

   ```
   HashMap<Integer, Integer> keyToFreq;
   ```

   3、这个需求应该是 LFU 算法的核心，所以我们分开说。

   3.1、首先，肯定是需要 `freq` 到 `key` 的映射，用来找到 `freq` 最小的 `key`。

   3.2、将 `freq` 最小的 `key` 删除，那你就得快速得到当前所有 `key` 最小的 `freq` 是多少。想要时间复杂度 O(1) 的话，肯定不能遍历一遍去找，那就用一个变量 `minFreq` 来记录当前最小的 `freq` 吧。

   3.3、可能有多个 `key` 拥有相同的 `freq`，所以 **`freq`** **对** **`key`** **是一对多的关系**，即一个 `freq` 对应一个 `key` 的列表。

   3.4、希望 `freq` 对应的 `key` 的列表是**存在时序**的，便于快速查找并删除最旧的 `key`。

   3.5、希望**能够快速删除** **`key`** **列表中的任何一个** **`key`**，因为如果频次为 `freq` 的某个 `key` 被访问，那么它的频次就会变成 `freq+1`，就应该从 `freq` 对应的 `key` 列表中删除，加到 `freq+1` 对应的 `key` 的列表中。

   ```
   HashMap<Integer, LinkedHashSet<Integer>> freqToKeys;
   int minFreq = 0;
   ```

   介绍一下这个 `LinkedHashSet`，它满足我们 3.3，3.4，3.5 这几个要求。你会发现普通的链表 `LinkedList` 能够满足 3.3，3.4 这两个要求，但是由于普通链表不能快速访问链表中的某一个节点，所以无法满足 3.5 的要求。

   `LinkedHashSet` 顾名思义，是链表和哈希集合的结合体。链表不能快速访问链表节点，但是插入元素具有时序；哈希集合中的元素无序，但是可以对元素进行快速的访问和删除。

   ![Image](pic\013.jpg)

   ```java
   class LFUCache {
       // key 到 val 的映射，我们后文称为 KV 表
       HashMap<Integer, Integer> keyToVal;
       // key 到 freq 的映射，我们后文称为 KF 表
       HashMap<Integer, Integer> keyToFreq;
       // freq 到 key 列表的映射，我们后文称为 FK 表
       HashMap<Integer, LinkedHashSet<Integer>> freqToKeys;
       // 记录最小的频次
       int minFreq;
       // 记录 LFU 缓存的最大容量
       int cap;
   
       public LFUCache(int capacity) {
           keyToVal = new HashMap<>();
           keyToFreq = new HashMap<>();
           freqToKeys = new HashMap<>();
           this.cap = capacity;
           this.minFreq = 0;
       }
   
       public int get(int key) {
           if (!keyToVal.containsKey(key)) {
               return -1;
           }
           // 增加 key 对应的 freq
           increaseFreq(key);
           return keyToVal.get(key);
       }
   
       public void put(int key, int val) {
           if (this.cap <= 0) return;
   
           /* 若 key 已存在，修改对应的 val 即可 */
           if (keyToVal.containsKey(key)) {
               keyToVal.put(key, val);
               // key 对应的 freq 加一
               increaseFreq(key);
               return;
           }
   
           /* key 不存在，需要插入 */
           /* 容量已满的话需要淘汰一个 freq 最小的 key */
           if (this.cap <= keyToVal.size()) {
               removeMinFreqKey();
           }
   
           /* 插入 key 和 val，对应的 freq 为 1 */
           // 插入 KV 表
           keyToVal.put(key, val);
           // 插入 KF 表
           keyToFreq.put(key, 1);
           // 插入 FK 表
           freqToKeys.putIfAbsent(1, new LinkedHashSet<>());
           freqToKeys.get(1).add(key);
           // 插入新 key 后最小的 freq 肯定是 1
           this.minFreq = 1;
       }
       
   	private void removeMinFreqKey() {
           // freq 最小的 key 列表
           LinkedHashSet<Integer> keyList = freqToKeys.get(this.minFreq);
           // 其中最先被插入的那个 key 就是该被淘汰的 key
           int deletedKey = keyList.iterator().next();
           /* 更新 FK 表 */
           keyList.remove(deletedKey);
           if (keyList.isEmpty()) {
               freqToKeys.remove(this.minFreq);
               // 问：这里需要更新 minFreq 的值吗？
           }
           /* 更新 KV 表 */
           keyToVal.remove(deletedKey);
           /* 更新 KF 表 */
           keyToFreq.remove(deletedKey);
       }
       
       private void increaseFreq(int key) {
           int freq = keyToFreq.get(key);
           /* 更新 KF 表 */
           keyToFreq.put(key, freq + 1);
           /* 更新 FK 表 */
           // 将 key 从 freq 对应的列表中删除
           freqToKeys.get(freq).remove(key);
           // 将 key 加入 freq + 1 对应的列表中
           freqToKeys.putIfAbsent(freq + 1, new LinkedHashSet<>());
           freqToKeys.get(freq + 1).add(key);
           // 如果 freq 对应的列表空了，移除这个 freq
           if (freqToKeys.get(freq).isEmpty()) {
               freqToKeys.remove(freq);
               // 如果这个 freq 恰好是 minFreq，更新 minFreq
               if (freq == this.minFreq) {
                   this.minFreq++;
               }
           }
       }
   }
   ```

## 设计推特

描述：设计一个简化版的推特(Twitter)，可以让用户实现发送推文，关注/取消关注其他用户，能够看见关注人（包括自己）的最近十条推文。你的设计需要支持以下的几个功能：

postTweet(userId, tweetId): 创建一条新的推文
getNewsFeed(userId): 检索最近的十条推文。每个推文都必须是由此用户关注的人或者是用户自己发出的。推文必须按照时间顺序由最近的开始排序。
follow(followerId, followeeId): 关注一个用户
unfollow(followerId, followeeId): 取消关注一个用户

思路：之所以要把 Tweet 和 User 类放到 Twitter 类里面，是因为 Tweet 类必须要用到一个全局时间戳 timestamp，而 User 类又需要用到 Tweet 类记录用户发送的推文，所以它们都作为内部类。

每个 Tweet 实例需要记录自己的 tweetId 和发表时间 time，而且作为链表节点，要有一个指向下一个节点的 next 指针。

我们根据实际场景想一想，一个用户需要存储的信息有 userId，关注列表，以及该用户发过的推文列表。其中关注列表应该用集合（Hash Set）这种数据结构来存，因为不能重复，而且需要快速查找；推文列表应该由链表这种数据结构储存，以便于进行有序合并的操作。除此之外，根据面向对象的设计原则，「关注」「取关」和「发文」应该是 User 的行为，况且关注列表和推文列表也存储在 User 类中，所以我们也应该给 User 添加 follow，unfollow 和 post 这几个方法

实现合并 k 个有序链表的算法需要用到优先级队列（Priority Queue），这种数据结构是「二叉堆」最重要的应用，你可以理解为它可以对插入的元素自动排序。乱序的元素插入其中就被放到了正确的位置，可以按照从小到大（或从大到小）有序地取出元素。

![img](pic\014.jpg)

```java
class Twitter {
    private static int timestamp = 0;
    private static class Tweet {
        private int id;
        private int time;
        private Tweet next;

        // 需要传入推文内容（id）和发文时间
        public Tweet(int id, int time) {
            this.id = id;
            this.time = time;
            this.next = null;
        }
    }
    
    private static class User {
        private int id;
        public Set<Integer> followed;
        // 用户发表的推文链表头结点
        public Tweet head;

        public User(int userId) {
            followed = new HashSet<>();
            this.id = userId;
            this.head = null;
            // 关注一下自己
            follow(id);
        }

        public void follow(int userId) {
            followed.add(userId);
        }

        public void unfollow(int userId) {
            // 不可以取关自己
            if (userId != this.id)
                followed.remove(userId);
        }

        public void post(int tweetId) {
            Tweet twt = new Tweet(tweetId, timestamp);
            timestamp++;
            // 将新建的推文插入链表头
            // 越靠前的推文 time 值越大
            twt.next = head;
            head = twt;
        }
    }
    // 我们需要一个映射将 userId 和 User 对象对应起来
    private HashMap<Integer, User> userMap = new HashMap<>();

    /** user 发表一条 tweet 动态 */
    public void postTweet(int userId, int tweetId) {
        // 若 userId 不存在，则新建
        if (!userMap.containsKey(userId))
            userMap.put(userId, new User(userId));
        User u = userMap.get(userId);
        u.post(tweetId);
    }
    
    /** 返回该 user 关注的人（包括他自己）最近的动态 id，
    最多 10 条，而且这些动态必须按从新到旧的时间线顺序排列。*/
    public List<Integer> getNewsFeed(int userId) {
        List<Integer> res = new ArrayList<>();
        if (!userMap.containsKey(userId)) return res;
        // 关注列表的用户 Id
        Set<Integer> users = userMap.get(userId).followed;
        // 自动通过 time 属性从大到小排序，容量为 users 的大小
        PriorityQueue<Tweet> pq = 
            new PriorityQueue<>(users.size(), (a, b)->(b.time - a.time));

        // 先将所有链表头节点插入优先级队列
        for (int id : users) {
            Tweet twt = userMap.get(id).head;
            if (twt == null) continue;
            pq.add(twt);
        }

        while (!pq.isEmpty()) {
            // 最多返回 10 条就够了
            if (res.size() == 10) break;
            // 弹出 time 值最大的（最近发表的）
            Tweet twt = pq.poll();
            res.add(twt.id);
            // 将下一篇 Tweet 插入进行排序
            if (twt.next != null) 
                pq.add(twt.next);
        }
        return res;
    }
    
    /** follower 关注 followee */
    public void follow(int followerId, int followeeId) {
        // 若 follower 不存在，则新建
        if(!userMap.containsKey(followerId)){
            User u = new User(followerId);
            userMap.put(followerId, u);
        }
        // 若 followee 不存在，则新建
        if(!userMap.containsKey(followeeId)){
            User u = new User(followeeId);
            userMap.put(followeeId, u);
        }
        userMap.get(followerId).follow(followeeId);
    }
    /** follower 取关 followee，如果 Id 不存在则什么都不做 */
    public void unfollow(int followerId, int followeeId) {
        if (userMap.containsKey(followerId)) {
            User flwer = userMap.get(followerId);
            flwer.unfollow(followeeId);
        }
    }
}
```

## 去除重复字母

描述：给你一个字符串 `s` ，请你去除字符串中重复的字母，使得每个字母只出现一次。需保证 **返回结果的字典序最小**（要求不能打乱其他字符的相对位置）。

思路：

要求一、**要去重**。

要求二、去重字符串中的字符顺序**不能打乱`s`中字符出现的相对顺序**。

要求三、在所有符合上一条要求的去重字符串中，**字典序最小**的作为最终结果。

**我们的算法在`stk.peek() > c`时才会 pop 元素，其实这时候应该分两种情况**：

情况一、如果`stk.peek()`这个字符之后还会出现，那么可以把它 pop 出去，反正后面还有嘛，后面再 push 到栈里，刚好符合字典序的要求。

情况二、如果`stk.peek()`这个字符之后不会出现了，前面也说了栈中不会存在重复的元素，那么就不能把它 pop 出去，否则你就永远失去了这个字符。

方法：

要求一、通过`inStack`这个布尔数组做到栈`stk`中不存在重复元素。

要求二、我们顺序遍历字符串`s`，通过「栈」这种顺序结构的 push/pop 操作记录结果字符串，保证了字符出现的顺序和`s`中出现的顺序一致。

这里也可以想到为什么要用「栈」这种数据结构，因为先进后出的结构允许我们立即操作刚插入的字符，如果用「队列」的话肯定是做不到的。

要求三、我们用类似单调栈的思路，配合计数器`count`不断 pop 掉不符合最小字典序的字符，保证了最终得到的结果字典序最小。

```java
String removeDuplicateLetters(String s) {
    Stack<Character> stk = new Stack<>();

    // 维护一个计数器记录字符串中字符的数量
    // 因为输入为 ASCII 字符，大小 256 够用了
    int[] count = new int[256];
    for (int i = 0; i < s.length(); i++) {
        count[s.charAt(i)]++;
    }

    boolean[] inStack = new boolean[256];
    for (char c : s.toCharArray()) {
        // 每遍历过一个字符，都将对应的计数减一
        count[c]--;

        if (inStack[c]) continue;

        while (!stk.isEmpty() && stk.peek() > c) {
            // 若之后不存在栈顶元素了，则停止 pop
            if (count[stk.peek()] == 0) {
                break;
            }
            // 若之后还有，则可以 pop
            inStack[stk.pop()] = false;
        }
        stk.push(c);
        inStack[c] = true;
    }

    StringBuilder sb = new StringBuilder();
    while (!stk.empty()) {
        sb.append(stk.pop());
    }
    return sb.reverse().toString();
}
```

