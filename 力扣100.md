# 一、两数之和

描述：给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 的那 两个 整数，并返回它们的数组下标。你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。

```java
// 时间复杂度：O(n)
// 空间复杂度：O(n)
// 空间换时间
public int[] twoSum(int[] nums, int target) {
    if (nums == null || nums.length == 0) return new int[0];
    int n = nums.length;

    Map<Integer, Integer> map = new HashMap<>();
    for (int i = 0; i < n; i++) { // O(n)
        int x = nums[i];
        // 哈希查找
        if (map.containsKey(target - x)) {
            int index = map.get(target - x);
            return new int[]{i, index};
        }
        map.put(x, i);
    }
    return new int[0];
}
```

# 二、两数相加

描述：给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。请你将两个数相加，并以相同形式返回一个表示和的链表。你可以假设除了数字 0 之外，这两个数都不会以 0 开头。

```c++
ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
    ListNode *head = nullptr, *tail = nullptr;
    int carry = 0;
    while (l1 || l2) {
        int n1 = l1 ? l1->val: 0;
        int n2 = l2 ? l2->val: 0;
        int sum = n1 + n2 + carry;
        if (!head) {
            head = tail = new ListNode(sum % 10);
        } else {
            tail->next = new ListNode(sum % 10);
            tail = tail->next;
        }
        carry = sum / 10;
        if (l1) {
            l1 = l1->next;
        }
        if (l2) {
            l2 = l2->next;
        }
    }
    if (carry > 0) {
        tail->next = new ListNode(carry);
    }
    return head;
}
```

# 三、无重复字符的最长子串

描述：给定一个字符串，请你找出其中不含有重复字符的 **最长子串** 的长度。

```c++
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        int n = s.size();
        if (0 == n) {
            return 0;
        }
        // rk为右端点
        int rk = -1, ans = 0;
        unordered_set<char> cnt;
        // i为左端点
        for (int i = 0; i < n; ++i) {
            // 每次遍历，以i为起点
            if (0 != i) {
                cnt.erase(s[i - 1]);
            }
            // 右指针没到头，且区间内没有重复字符，向右扩展
            while (rk + 1 < n && !cnt.count(s[rk + 1])) {
                cnt.insert(s[++rk]);  
            }
            // 右指针遇到了重复字符，更新最大长度
            ans = max(ans, rk - i + 1);
        }
        return ans;
    }
};
```

# 四、寻找两个正序数组的中位数

描述：给定两个大小分别为 `m` 和 `n` 的正序（从小到大）数组 `nums1` 和 `nums2`。请你找出并返回这两个正序数组的 **中位数** 。

```c++
class Solution {
public:
    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
        int n = nums1.size();
        int m = nums2.size();
        // 第left，right个数分别是用来求中位数的。
        // 如果是奇数，left=right。第left个数就是中位数。
        // 如果是偶数，二者除2是中位数
        int left = (m + n + 1) / 2;
        int right = (m + n + 2) / 2;
        // 分别找出第left和第right个数
        return (getKth(nums1, 0, n - 1, nums2, 0, m - 1, left) + getKth(nums1, 0, n - 1, nums2, 0, m - 1, right)) * 0.5;
    }

    int getKth(vector<int>& nums1, int start1, int end1, vector<int>& nums2, int start2, int end2, int k) {
        // 两个数组中符合当前条件元素的个数
        int len1 = end1 - start1 + 1;
        int len2 = end2 - start2 + 1;
        // 让len1<len2
        if (len1 > len2) {
            return getKth(nums2, start2, end2, nums1, start1, end1, k);
        }
        // 找到中位数
        if (0 == len1) {
            return nums2[start2 + k - 1];
        }
        // 接近中位数，值小的就是
        if (1 == k) {
            return min(nums1[start1], nums2[start2]);
        }
        // 分别在两个数组寻找中位数
        int i = start1 + min(len1, k / 2) - 1;
        int j = start2 + min(len2, k / 2) - 1;
        // nums2中比j小的索引全都不要了，k中减去对应的数
        if (nums1[i] > nums2[j]) {
            return getKth(nums1, start1, end1, nums2, j + 1, end2, k - (j - start2 + 1));
        } else {
            return getKth(nums1, i + 1, end1, nums2, start2, end2, k - (i - start1 + 1));
        }
    }
};
```

# 五、最长回文子串

```c++
class Solution {
public:
    pair<int, int> expandAroundCenter(const string& s, int left, int right) {
        while (left >= 0 && right < s.size() && s[left] == s[right]) {
            --left;
            ++right;
        }
        return {left + 1, right - 1};
    }

    string longestPalindrome(string s) {
        int start = 0, end = 0;
        for (int i = 0; i < s.size(); ++i) {
            auto [left1, right1] = expandAroundCenter(s, i, i);
            auto [left2, right2] = expandAroundCenter(s, i, i + 1);
            if (right1 - left1 > end - start) {
                start = left1;
                end = right1;
            }
            if (right2 - left2 > end - start) {
                start = left2;
                end = right2;
            }
        }
        return s.substr(start, end - start + 1);
    }
};
```

# 六、正则表达式匹配

```c++
class Solution {
public:
    bool isMatch(string s, string p) {
        s=" "+s;//防止该案例：""\n"c*"
        p=" "+p;
        int m = s.size(), n = p.size();
        // 矩阵，存储所有的匹配可能。因为s和p都加上了一个空格，所以长度+1
        bool dp[m+1][n+1];
        memset(dp, false, (m+1)*(n+1));
        dp[0][0] = true;
        for (int i = 1; i <= m; ++i) {
            for (int j = 1; j <= n; ++j) {
                // m, n存储在这之前是否成功
                if (s[i - 1] == p[j - 1] || p[j - 1] == '.') {
                    // 匹配成功。如果前面的是成功的，则成功。如果前面失败了，也失败
                    dp[i][j] = dp[i - 1][j - 1];
                } else if (p[j - 1] == '*') {
                    if (s[i - 1] != p[j - 2] && p[j - 2] != '.') {
                        // *匹配了0个字符，*是第j-1个，如果*前面的字符匹配成功，则*所在的位置也成功
                        // abbb  abc*a
                        dp[i][j] = dp[i][j - 2];
                    } else {
                        // *匹配了*前面0个或多个字符。j-1表示一个，j-2表示0个，i-1表示多个
                        dp[i][j] = dp[i][j-1] || dp[i][j-2] || dp[i-1][j];
                    }
                }
            }
        }
        return dp[m][n];
    }
};
```

# 七、盛最多水的容器

描述：给你 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0) 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。

```c++
class Solution {
public:
    int maxArea(vector<int>& height) {
        int n = height.size();
        if (n < 2) {
            return 0;
        }
        int i = 0, j = n - 1, area = 0, maxarea = 0;
        while (i < j) {
            if (height[i] < height[j]) {
                area = height[i] * (j - i);
                ++i;
            } else {
                area = height[j] * (j - i);
                --j;
            }
            maxarea = max(area, maxarea);
        }
        return maxarea;
    }
};
```

# 八、三数之和

```c++
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        int n = nums.size();
        vector<vector<int>> result;
        // 升序排序
        sort(nums.begin(), nums.end());
        for (int i = 0; i < n; ++i) {
            if (nums[i] > 0) {
                return result;
            }
            if (i > 0 && nums[i] == nums[i - 1]) {
                continue;
            }
            int j = i + 1, k = n - 1;
            while (j < k) {
                if (nums[i] + nums[j] > 0) {
                    break;
                }
                if (nums[i] + nums[j] + nums[k] < 0) {
                    ++j;
                    while (j < k && nums[j] == nums[j - 1]) ++j;
                } else if (nums[i] + nums[j] + nums[k] > 0) {
                    --k;
                    while (j < k && nums[k] == nums[k + 1]) --k;
                } else {
                    result.push_back({nums[i], nums[j], nums[k]});
                    ++j;
                    --k;
                    while (j < k && nums[j] == nums[j - 1]) ++j;
                    while (j < k && nums[k] == nums[k + 1]) --k;
                }
            }
        }
        return result;
    }
};
```

# 九、电话号码的字母组合

描述：给定一个仅包含数字 `2-9` 的字符串，返回所有它能表示的字母组合。答案可以按 **任意顺序** 返回。

```c++
class Solution {
public:
    vector<string> letterCombinations(string digits) {
        vector<string> combinations;
        if (digits.empty()) {
            return combinations;
        }
        unordered_map<char, string> phoneMap{
            {'2', "abc"},
            {'3', "def"},
            {'4', "ghi"},
            {'5', "jkl"},
            {'6', "mno"},
            {'7', "pqrs"},
            {'8', "tuv"},
            {'9', "wxyz"}
        };
        string combination;
        backtrack(combinations, phoneMap, digits, 0, combination);
        return combinations;
    }

    void backtrack(vector<string>& combinations, const unordered_map<char, string>& phoneMap, const string& digits, int index, string& combination) {
        // 递归出口，已经遍历到头，得到一个结果
        if (index == digits.length()) {
            combinations.push_back(combination);
        } else {
            // 取出第index个数字
            char digit = digits[index];
            // 取出该数字对应的字符
            const string& letters = phoneMap.at(digit);
            // 遍历数字对应的每个字符
            for (const char& letter : letters) {
                combination.push_back(letter);
                // 回溯，遍历下一个数字里的字符
                backtrack(combinations, phoneMap, digits, index + 1, combination);
                // 经过递归出口，成功找出了一个结果。弹出一个字符，继续检查该数字中其他字符
                combination.pop_back();
            }
        }
    }
};
```

# 十、删除链表的倒数第N个节点

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        ListNode* dummy = new ListNode(0, head);
        ListNode* first = head;
        ListNode* second = dummy;
        for (int i = 0; i < n; ++i) {
            first = first->next;
        }
        while (first) {
            first = first->next;
            second = second->next;
        }
        second->next = second->next->next;
        ListNode* ans = dummy->next;
        delete dummy;
        return ans;
    }
};
```

# 十一、括号生成

描述：数字 `n` 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 **有效的** 括号组合。

慢速版

```c++
class Solution {
    vector<string> res;
public:
    vector<string> generateParenthesis(int n) {
        if (n < 1) {
            return res;
        }
        getParenthesis("", n, n, 0);
        return res;
    }
    void getParenthesis(string str, int left, int right, int count) {
        if(left == 0 && right == 0 ) {
            res.push_back(str);
            return;
        }
        //剩余左右括号数相等，下一个只能用左括号
        if (left == right) {
            str.push_back('(');
            getParenthesis(str, left - 1, right, count + 1);
            str.pop_back();
        } else if (left < right) {
            //剩余左括号小于右括号，下一个可以用左括号也可以用右括号
            if (left > 0) {
                str.push_back('(');
                getParenthesis(str, left - 1, right, count + 1);
                str.pop_back();
            }
            str.push_back(')');
            getParenthesis(str, left, right - 1, count + 1);
            str.pop_back();
        }
    }
};
```

官方快速版

```c++
class Solution {
    shared_ptr<vector<string>> cache[100] = {nullptr};
public:
    // 任何一个括号序列都一定是由 ( 开头，并且第一个 ( 一定有一个唯一与之对应的 )。每一个括号序列可以用 (a)b 来表示，其中 a 与 b 分别是一个合法的括号序列（可以为空）。
    shared_ptr<vector<string>> generate(int n) {
        if (cache[n] != nullptr)
            return cache[n];
        if (n == 0) {
            cache[0] = shared_ptr<vector<string>>(new vector<string>{""});
        } else {
            // 我们需要枚举与第一个 ( 对应的 ) 的位置 2 * i + 1；
            auto result = shared_ptr<vector<string>>(new vector<string>);
            for (int i = 0; i != n; ++i) {
                // 递归调用 generate(i) 即可计算 a 的所有可能性；
                auto lefts = generate(i);
                // 递归调用 generate(n - i - 1) 即可计算 b 的所有可能性；
                auto rights = generate(n - i - 1);
                // 遍历 a 与 b 的所有可能性并拼接，即可得到所有长度为 2 * n 的括号序列。
                for (const string& left : *lefts)
                    for (const string& right : *rights)
                        result -> push_back("(" + left + ")" + right);
            }
            cache[n] = result;
        }
        // 为了节省计算时间，我们在每次 generate(i) 函数返回之前，把返回值存储起来，下次再调用 generate(i) 时可以直接返回，不需要再递归计算。
        return cache[n];
    }
    vector<string> generateParenthesis(int n) {
        return *generate(n);
    }
};
```

# 十二、下一个排列

描述：实现获取 下一个排列 的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。必须 原地 修改，只允许使用额外常数空间。

```c++
class Solution {
public:
    void nextPermutation(vector<int>& nums) {
        int i = nums.size() - 2;
        // 我们需要将一个左边的「较小数」与一个右边的「较大数」交换，以能够让当前排列变大，从而得到下一个排列。
        while (i >= 0 && nums[i] >= nums[i + 1]) {
            // 令i右边的数比i所在的数大
            --i;
        }
        if (i >= 0) {
            int j = nums.size() - 1;
            // 同时我们要让这个「较小数」尽量靠右，而「较大数」尽可能小。
            while (j >= 0 && nums[i] >= nums[j]) {
                // 从右侧找到第一个比右侧最小数大的元素
                j--;
            }
            swap(nums[i], nums[j]);
        }
        // 当交换完成后，「较大数」右边的数需要按照升序重新排列。这样可以在保证新排列大于原来排列的情况下，使变大的幅度尽可能小。
        reverse(nums.begin() + i + 1, nums.end());
    }
};
```

# 十三、合并K个升序链表

```c++
class Solution {
public:
    // 配对
    ListNode* mergeTwoLists(ListNode *a, ListNode *b) {
        if ((!a) || (!b)) return a ? a : b;
        ListNode head, *tail = &head, *aPtr = a, *bPtr = b;
        while (aPtr && bPtr) {
            if (aPtr->val < bPtr->val) {
                tail->next = aPtr; aPtr = aPtr->next;
            } else {
                tail->next = bPtr; bPtr = bPtr->next;
            }
            tail = tail->next;
        }
        tail->next = (aPtr ? aPtr : bPtr);
        return head.next;
    }

    ListNode* merge(vector <ListNode*> &lists, int l, int r) {
        if (l == r) return lists[l];
        if (l > r) return nullptr;
        int mid = (l + r) >> 1;
        return mergeTwoLists(merge(lists, l, mid), merge(lists, mid + 1, r));
    }

    ListNode* mergeKLists(vector<ListNode*>& lists) {
        return merge(lists, 0, lists.size() - 1);
    }
};
```

# 十四、最长有效括号

描述：给你一个只包含 `'('` 和 `')'` 的字符串，找出最长有效（格式正确且连续）括号子串的长度。

```c++
int longestValidParentheses(string s) {
    int left = 0, right = 0, maxlength = 0;
    // 当前字符下标结尾的有效括号长度，每次当右括号数量多于左括号数量的时候之前的字符我们都扔掉不再考虑，重新从下一个字符开始计算
    for (int i = 0; i < s.length(); i++) {
        if (s[i] == '(') {
            left++;
        } else {
            right++;
        }
        if (left == right) {
            maxlength = max(maxlength, 2 * right);
        } else if (right > left) {
            left = right = 0;
        }
    }
    // 解决遍历的时候左括号的数量始终大于右括号的数量，即 (()
    left = right = 0;
    for (int i = (int)s.length() - 1; i >= 0; i--) {
        if (s[i] == '(') {
            left++;
        } else {
            right++;
        }
        if (left == right) {
            maxlength = max(maxlength, 2 * left);
        } else if (left > right) {
            left = right = 0;
        }
    }
    return maxlength;
}
```

# 十五、搜索旋转排序数组

描述：整数数组 nums 按升序排列，数组中的值 互不相同 。在传递给函数之前，nums 在预先未知的某个下标 k（0 <= k < nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]（下标 从 0 开始 计数）。给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的索引，否则返回 -1 。

```c++
int search(vector<int>& nums, int target) {
    int n = (int)nums.size();
    if (!n) {
        return -1;
    }
    if (n == 1) {
        return nums[0] == target ? 0 : -1;
    }
    int l = 0, r = n - 1;
    while (l <= r) {
        int mid = (l + r) / 2;
        if (nums[mid] == target) return mid;
        // 如果中点在在旋转数组前半段
        if (nums[0] <= nums[mid]) {
            // 如果目标也在旋转数组前半段，并且在头结点和中点之间，更新r
            if (nums[0] <= target && target < nums[mid]) {
                r = mid - 1;
            } else {
                // 目标在中点后面，更新l
                l = mid + 1;
            }
        } else {
            // 如果中点在旋转数组后半段，并且目标在中点后面，更新l
            if (nums[mid] < target && target <= nums[n - 1]) {
                l = mid + 1;
            } else {
                // 目标在中点之前，更新r
                r = mid - 1;
            }
        }
    }
    return -1;
}
```

# 十六、在排序数组中查找元素的第一个和最后一个位置

描述：给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。如果数组中不存在目标值 target，返回 [-1, -1]。

思路：找到第一个target和第一个大于target的位置-1.

```c++
class Solution { 
public:
    // 如果lower为true，则查找第一个>=target的下标。否则查找第一个>target的下标。
    int binarySearch(vector<int>& nums, int target, bool lower) {
        int left = 0, right = (int)nums.size() - 1, ans = (int)nums.size();
        while (left <= right) {
            int mid = (left + right) / 2;
            if (nums[mid] > target || (lower && nums[mid] >= target)) {
                right = mid - 1;
                ans = mid;
            } else {
                left = mid + 1;
            }
        }
        return ans;
    }

    vector<int> searchRange(vector<int>& nums, int target) {
        // 第一个target
        int leftIdx = binarySearch(nums, target, true);
        // 第一个大于target的位置-1
        int rightIdx = binarySearch(nums, target, false) - 1;
        // 校验得到的两个下标是否符合条件，target存在
        if (leftIdx <= rightIdx && rightIdx < nums.size() && nums[leftIdx] == target && nums[rightIdx] == target) {
            return vector<int>{leftIdx, rightIdx};
        } 
        return vector<int>{-1, -1};
    }
};
```

# 十七、组合总和

描述：给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。candidates 中的数字可以无限制重复被选取。

```c++
class Solution {
    vector<vector<int>> res;
    void dfs(vector<int>& candidates, int target, vector<int>& combine, int idx) {
        // 递归结束，没找到目标
        if (idx == candidates.size()) {
            return;
        }
        // 找到目标
        if (0 == target) {
            res.emplace_back(combine);
            return;
        }
        // 直接跳过，不选择当前数
        dfs(candidates, target, combine, idx + 1);
        // 选择当前数
        if (target - candidates[idx] >= 0) {
            combine.emplace_back(candidates[idx]);
            dfs(candidates, target - candidates[idx], combine, idx);
            combine.pop_back();
        }
    }
public:
    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
        vector<int> combine;
        dfs(candidates, target, combine, 0);
        return res;
    }
};
```

# 十八、接雨水

描述：给定 *n* 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。

```c++
class Solution {
public:
    int trap(vector<int>& height) {
        int n = height.size();
        if (0 == n) {
            return 0;
        }
        int sum = 0;
        // 双指针
        int left = 0, right = n - 1;
        int left_max = 0, right_max = 0;
        while (left < right) {
            // 左边比右边低，检查左边是否>当前左边的最高柱子，是的话更新。否则累计到结果中(因为右边的比坐标的高，所以此处一定是个洼地)。左指针右移
            if (height[left] < height[right]) {
                height[left] > left_max ? (left_max = height[left]) : 
                sum += (left_max - height[left]);
                ++left;
            } else {
                // 右边比左边低或者一样高，进行和上面一样的操作
                height[right] > right_max ? (right_max = height[right]) : 
                sum += (right_max - height[right]);
                --right;
            }
            // 当左右指针重合，遍历结束
        }
        return sum;
    }
};
```

# 十九、全排列

描述：给定一个 **没有重复** 数字的序列，返回其所有可能的全排列。

```c++
class Solution {
    vector<vector<int>> res;
    void backtrack(vector<int>& nums, int first, int len) {
        // 所有数都填完了
        if (first == len) {
            res.emplace_back(nums);
            return;
        }
        for (int i = first; i < len; ++i) {
            // 动态维护数组
            swap(nums[i], nums[first]);
            // 继续递归填下一个数
            backtrack(nums, first + 1, len);
            // 撤销操作
            swap(nums[i], nums[first]);
        }
    }
public:
    vector<vector<int>> permute(vector<int>& nums) {
        backtrack(nums, 0, (int)nums.size());
        return res;
    }
};
```

# 二十、旋转图像

描述：给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。

你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。

```c++
class Solution {
public:
    void rotate(vector<vector<int>>& matrix) {
        int n = matrix.size();
        if (0 == n) {
            return;
        }
        // 右上，左下翻转
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < n - i; ++j) {
                swap(matrix[i][j], matrix[n - j - 1][n - i - 1]);
            }
        }
        // 沿水平中线上下翻转
        for (int i = 0; i < (n >> 1); ++i) {
            for (int j = 0; j < n; ++j) {
                swap(matrix[i][j], matrix[n - i - 1][j]);
            }
        }
    }
};
```

# 二十一、字母异位词分组

描述：给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。

```c++
class Solution {
public:
    vector<vector<string>> groupAnagrams(vector<string>& strs) {
        unordered_map<string, vector<string>> mp;
        vector<vector<string>> result;
        for (string &s : strs) {
            string key = s;
            sort(key.begin(), key.end());
            // 在value中把原字符串添加到vector中
            mp[key].emplace_back(s);
        }
        for (auto i : mp) {
            result.emplace_back(i.second);
        }
        return result;
    }
};
```

# 二十二、最大子序和

描述：给定一个整数数组 `nums` ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

```c++
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int n = nums.size();
        int res = INT_MIN, cur = INT_MIN;
        for (int i = 0; i < n; ++i) {
            if (cur <= 0) {
                cur = nums[i];
            } else {
                cur += nums[i];
            }
            if (cur > res) {
                res = cur;
            }
        }
        return res;
    }
};
```

# 二十三、跳跃游戏

描述：给定一个非负整数数组 `nums` ，你最初位于数组的 **第一个下标** 。

数组中的每个元素代表你在该位置可以跳跃的最大长度。

判断你是否能够到达最后一个下标。

```c++
class Solution {
public:
    bool canJump(vector<int>& nums) {
        int n = nums.size();
        int rightmost = 0;
        for (int i = 0; i < n; ++i) {
            if (i <= rightmost) {
                rightmost = max(rightmost, i + nums[i]);
                if (rightmost >= n - 1) {
                    return true;
                }
            }
        }
        return false;
    }
};
```

# 二十四、合并区间

描述：以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。

```c++
class Solution {
public:
    vector<vector<int>> merge(vector<vector<int>>& intervals) {
        int n = intervals.size();
        vector<vector<int>> res;
        if (0 == n) {
            return res;
        }
        sort(intervals.begin(), intervals.end());
        for (int i = 0; i < n; ++i) {
            int L = intervals[i][0], R = intervals[i][1];
            if (!res.size() || res.back()[1] < L) {
                res.push_back({L, R});
            } else {
                res.back()[1] = max(res.back()[1], R);
            }
        }
        return res;
    }
};
```

```java
class Solution {
    public int[][] merge(int[][] intervals) {
        if (intervals.length == 0) {
            return new int[0][2];
        }
        Arrays.sort(intervals, new Comparator<int[]>() {
            public int compare(int[] interval1, int[] interval2) {
                return interval1[0] - interval2[0];
            }
        });
        List<int[]> merged = new ArrayList<int[]>();
        for (int i = 0; i < intervals.length; ++i) {
            int L = intervals[i][0], R = intervals[i][1];
            if (merged.size() == 0 || merged.get(merged.size() - 1)[1] < L) {
                merged.add(new int[]{L, R});
            } else {
                merged.get(merged.size() - 1)[1] = Math.max(merged.get(merged.size() - 1)[1], R);
            }
        }
        return merged.toArray(new int[merged.size()][]);
    }
}
```



# 二十五、不同路径

描述：一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。

问总共有多少条不同的路径？

```c++
class Solution {
public:
    int uniquePaths(int m, int n) {
        vector<int> cur(n, 1);
        for (int i = 1; i < m; ++i) {
            for (int j = 1; j < n; ++j) {
                cur[j] += cur[j - 1];
            }
        }
        return cur[n - 1];
    }
};
```

# 二十六、最小路径和

描述：给定一个包含非负整数的 `m x n` 网格 `grid` ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。

**说明：**每次只能向下或者向右移动一步。

```c++
class Solution {
public:
    int minPathSum(vector<vector<int>>& grid) {
        int m = grid.size(), n = grid[0].size();
        if (0 == m || 0 == n) {
            return 0;
        }
        vector<vector<int>> path(m, vector<int>(n, 0));
        path[0][0] = grid[0][0];
        for (int i = 0; i <m; ++i) {
            for (int j = 0; j < n; ++j) {
                if (i > 0 && j > 0) {
                    path[i][j] = min(path[i - 1][j], path[i][j - 1]) + grid[i][j];
                } else if (i > 0) {
                    path[i][j] = path[i - 1][j] + grid[i][j];
                } else if (j > 0) {
                    path[i][j] = path[i][j - 1] + grid[i][j];
                }
            }
        }
        return path[m - 1][n - 1];
    }
};
```

# 二十七、爬楼梯

描述：假设你正在爬楼梯。需要 *n* 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

**注意：**给定 *n* 是一个正整数。

```c++
class Solution {
public:
    int climbStairs(int n) {
        int p = 0, q = 0, r = 1;
        for (int i = 1; i <= n; ++i) {
            p = q; 
            q = r; 
            r = p + q;
        }
        return r;
    }
};
```

# 二十九、编辑距离

```java
class Solution {
    public int minDistance(String word1, String word2) {
        int m = word1.length(), n = word2.length();
        int[][] dp = new int[m + 1][n + 1];
        for (int i = 1; i <= m; ++i) {
            dp[i][0] = i;
        }
        for (int j = 1; j <= n; ++j) {
            dp[0][j] = j;
        }
        for (int i = 1; i <= m; ++i) {
            for (int j = 1; j <= n; ++j) {
                if (word1.charAt(i - 1) == word2.charAt(j - 1)) {
                    dp[i][j] = dp[i - 1][j - 1];
                } else {
                    dp[i][j] = min(
                        dp[i - 1][j - 1], 
                        dp[i - 1][j], 
                        dp[i][j -1]
                    ) + 1;
                }
            }
        }
        return dp[m][n];
    }
    private int min(int a, int b, int c) {
        return Math.min(a, Math.min(b, c));
    }
}
```

# 三十、颜色分类

# 三十一、最小覆盖子串

```c++
string minWindow(string s, string t) {
    unordered_map<char, int> need, window;
    // 目标串每个字符出现的次数
    for (char c : t) need[c]++;
    int left = 0, right = 0;
    int valid = 0;
    // 记录最小覆盖子串的起始索引及长度
    int start = 0, len = INT_MAX;
    while (right < s.size()) {
        // c 是将移入窗口的字符
        char c = s[right];
        // 右移窗口
        right++;
        // 进行窗口内数据的一系列更新
        if (need.count(c)) {
            window[c]++;
            if (window[c] == need[c])
                valid++;
        }

        // 和模式串中的匹配字符已经满了，判断左侧窗口是否要收缩
        while (valid == need.size()) {
            // 在这里更新最小覆盖子串
            if (right - left < len) {
                start = left;
                len = right - left;
            }
            // d 是将移出窗口的字符
            char d = s[left];
            // 左移窗口
            left++;
            // 进行窗口内数据的一系列更新
            if (need.count(d)) {
                // 窗口中的数量和模式串中的数量相等时才将已经匹配的字符数量-1
                // 因为有可能窗口中有多个相同模式串中这个字符，此时不用更新有效匹配的数量
                if (window[d] == need[d])
                    valid--;
                window[d]--;
            }                    
        }
    }
    // 返回最小覆盖子串
    return len == INT_MAX ?
        "" : s.substr(start, len);
}
```

# 三十二、子集

# 三十四、单词搜索

# 三十五、柱状图中最大的矩形

思路：枚举一根柱子i向两边扩展，找到左右两侧最近的高度<h的柱子，得到i能扩展到的最远范围。

方法：从左向右遍历，维护一个数组，从小到大顺序存放j，height[j0]<height[j1]<...<height[js]，

height[j0]<...<height[ji]<height[i]<height[ji+1]<...<height[js]

```c++
class Solution {
public:
    int largestRectangleArea(vector<int>& heights) {
        int n = heights.size();
        // left[0...0], right[n...n]。left存放i左侧最远范围的坐标。right存放i右侧最远的范围。
        vector<int> left(n), right(n, n);
        // 单调栈，依次存放在i左侧比i低的元素。在i右侧依次存放比i高的元素下标
        stack<int> mono_stack;
        for (int i = 0; i < n; ++i) {
            // 当栈不空并且栈顶下标在数组中的高度比当前下标i所在高度大，更新right数组栈顶下标所在的元素为当前下标，出栈。意思是在栈顶这个位置向右最远扩展到i
            while (!mono_stack.empty() && heights[mono_stack.top()] >= heights[i]) {
                // 把在i左侧比i高的元素弹出，因为栈中降序，所以弹出的元素越来越小
                right[mono_stack.top()] = i;
                mono_stack.pop();
            }
            // 如果栈空更新left在i处为-1，栈顶下标在数组中的高度比当前高度小了的话left[i]更新为当前栈顶。并把i入栈。意思是在i这个位置向左最远扩展到-1或栈顶下标，而且栈顶下标向右至少可以扩展到i
            left[i] = (mono_stack.empty() ? -1 : mono_stack.top());
            // 把在i后面的元素左侧的i入栈，而且i为栈顶，栈里是在i左侧且比i低的高度下标
            mono_stack.push(i);
        }
        
        int ans = 0;
        for (int i = 0; i < n; ++i) {
            // 二者差值-1就是每个以i为中心扩展的小区间的宽度
            ans = max(ans, (right[i] - left[i] - 1) * heights[i]);
        }
        return ans;
    }
};
```

# 三十六、最大矩形

```c++
class Solution {
public:
    int maximalRectangle(vector<vector<char>>& matrix) {
        int m = matrix.size();
        if (m == 0) {
            return 0;
        }
        int n = matrix[0].size();
        vector<vector<int>> left(m, vector<int>(n, 0));

        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (matrix[i][j] == '1') {
                    // 存放以(i, j)为终点，向右连续为1的长度
                    left[i][j] = (j == 0 ? 0: left[i][j - 1]) + 1;
                }
            }
        }
		
        // 存储结果
        int ret = 0;
        // 对于每一列，使用基于柱状图的方法
        for (int j = 0; j < n; j++) {
            // up存放列中为可能的最大矩形的行起点，down存放列中可能为最大矩形的行终点。两者的差就是列中连续1长度
            vector<int> up(m, 0), down(m, 0);
			// 从上到下填充up数组
            stack<int> stk;
            // stk中存储当前行i上方的行
            for (int i = 0; i < m; i++) {
                /*              
                如果栈顶所在的行在j列从左到第j列连续为1的个数比i在j列连续为1的数量多，弹出。因为这说明在矩阵中是倒三角的形状，也就是当前行i不会成为新的最大矩形的上起点。
                直到找到一个栈顶在当前列为1的个数比i在当前列连续为1的个数少。当前第i行有可能成为最大矩形的上起点。
                第一行的up为-1
                */
                while (!stk.empty() && left[stk.top()][j] >= left[i][j]) {
                    stk.pop();
                }
                // 
                up[i] = stk.empty() ? -1 : stk.top();
                stk.push(i);
            }
            // 从下到上填充down数组
            /*
            从下开始找可能为最大矩形的行终点。初始为m。
            */
            stk = stack<int>();
            for (int i = m - 1; i >= 0; i--) {
                while (!stk.empty() && left[stk.top()][j] >= left[i][j]) {
                    stk.pop();
                }
                down[i] = stk.empty() ? m : stk.top();
                stk.push(i);
            }
            /*
            如果up[i]=-1, down[i]=m,说明该列从上到下都是同样的字符，如果是0，在和宽度相乘的时候变为0.如果是1，就可以得到该列的面积。否则只要该列产生过变化，就能找到从上到下以及从下到上看宽度增加的行。
            */
			// 计算面积
            for (int i = 0; i < m; i++) {
                int height = down[i] - up[i] - 1;
                int area = height * left[i][j];
                ret = max(ret, area);
            }
        }
        return ret;
    }
};
```



# 三十七、二叉树中序遍历

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> res;
        stack<TreeNode*> stk;
        while (root != nullptr || !stk.empty()) {
            while (root != nullptr) {
                stk.push(root);
                root = root->left;
            }
            root = stk.top();
            stk.pop();
            res.push_back(root->val);
            root = root->right;
        }
        return res;
    }
};
lass Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> res;
        TreeNode *predecessor = nullptr;

        while (root != nullptr) {
            if (root->left != nullptr) {
                // predecessor 节点就是当前 root 节点向左走一步，然后一直向右走至无法走为止
                predecessor = root->left;
                while (predecessor->right != nullptr && predecessor->right != root) {
                    predecessor = predecessor->right;
                }
                
                // 让 predecessor 的右指针指向 root，继续遍历左子树
                if (predecessor->right == nullptr) {
                    predecessor->right = root;
                    root = root->left;
                }
                // 说明左子树已经访问完了，我们需要断开链接
                else {
                    res.push_back(root->val);
                    predecessor->right = nullptr;
                    root = root->right;
                }
            }
            // 如果没有左孩子，则直接访问右孩子
            else {
                res.push_back(root->val);
                root = root->right;
            }
        }
        return res;
    }
};
```

# 三十八、不同的二叉搜索树

思路：遍历1~n每个数字，将该数字作为树根，1~(i-1)作为左子树，(i+1)~n作为右子树。递归继续构建。由于根不同，所以每棵树唯一。

G(n) = 长度为n的序列能构成不同的二叉搜索树个数。

F(i, n) = 以i为根，序列长度为n的不同二叉搜索树个数

```
G(n) = ΣF(i, n)
G(0) = 1, G(1) = 1
F(i, n) = G(i - 1) * G(n - i)
G(n) = ΣG(i - 1) * G(n - i)
```

```c++
class Solution {
public:
    int numTrees(int n) {
        vector<int> G(n + 1, 0);
        G[0] = 1;
        G[1] = 1;
		// i为每一个小子树的长度
        for (int i = 2; i <= n; ++i) {
            for (int j = 1; j <= i; ++j) {
                G[i] += G[j - 1] * G[i - j];
            }
        }
        return G[n];
    }
};
```

# 三十九、验证二叉搜索树

```c++
class Solution {
public:
    bool helper(TreeNode* root, long long lower, long long upper) {
        if (root == nullptr) {
            return true;
        }
        if (root -> val <= lower || root -> val >= upper) {
            return false;
        }
        return helper(root -> left, lower, root -> val) && helper(root -> right, root -> val, upper);
    }
    bool isValidBST(TreeNode* root) {
        return helper(root, LONG_MIN, LONG_MAX);
    }
};
```



# 最长连续序列

```c++
class Solution {
public:
    int longestConsecutive(vector<int>& nums) {
        unordered_set<int> num_set;
        for (const int& num : nums) {
            num_set.insert(num);
        }
        int longestStreak = 0;
        for (const int& num : num_set) {
            // num是一个序列的起点
            if (!num_set.count(num - 1)) {
                int currentNum = num;
                int currentStreak = 1;
                while (num_set.count(currentNum + 1)) {
                    ++currentNum;
                    ++currentStreak;
                }
                longestStreak = max(longestStreak, currentStreak);
            }
        }
        return longestStreak;
    }
};
```

# 环形链表

思路：设链表中环外部分长度为a。slow进入环后，走了b步和fast相遇，此时fast已经走了n圈。fast+slow走过的距离为:

`a + n(b+c) + b = a + (n+1)b + nc`

任意时刻fast走过的距离都为slow的2倍：`a + (n+1)b + nc = 2(a+b)`=>`a = c + (n-1)(b+c)`

从相遇点到入口距离c+(n-1)圈环长=头部到入口距离。

```java
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
        ListNode *slow = head, *fast = head;
        while (fast != nullptr) {
            slow = slow->next;
            if (fast->next == nullptr) {
                return nullptr;
            }
            fast = fast->next->next;
            if (fast == slow) {
                ListNode *ptr = head;
                while (ptr != slow) {
                    ptr = ptr->next;
                    slow = slow->next;
                }
                return ptr;
            }
        }
        return nullptr;
    }
};
```

# LRU

```java
class LRUCache {
    int cap;
    LinkedHashMap<Integer, Integer> cache = new LinkedHashMap<>();
    public LRUCache(int capacity) { 
        this.cap = capacity;
    }

    public int get(int key) {
        if (!cache.containsKey(key)) {
            return -1;
        }
        // 将 key 变为最近使用
        makeRecently(key);
        return cache.get(key);
    }

    public void put(int key, int val) {
        if (cache.containsKey(key)) {
            // 修改 key 的值
            cache.put(key, val);
            // 将 key 变为最近使用
            makeRecently(key);
            return;
        }

        if (cache.size() >= this.cap) {
            // 链表头部就是最久未使用的 key
            int oldestKey = cache.keySet().iterator().next();
            cache.remove(oldestKey);
        }
        // 将新的 key 添加链表尾部
        cache.put(key, val);
    }

    private void makeRecently(int key) {
        int val = cache.get(key);
        // 删除 key，重新插入到队尾
        cache.remove(key);
        cache.put(key, val);
    }
}
```

# 乘积最大子数组

```
fmax(i)=以nums[i]结尾的最大乘积子数组。
错误的公式：fmax = max{f(i-1)*nums[i], nums[i]}，这只是当前最优不是全局最优。
考虑当前位置的政府：
①如果当前位置是负数，那么希望以它前一个位置结尾的某个段的积也是负数，并且这个积尽可能小=>fmin(i)
	fmin(i) = min{fmax(i-1)*nums[i], fmin(i-1)*nums[i], nums[i]}
②如果当前位置是正数，希望以它前一个位置结尾的某个段的积也是正数，并且尽可能大=>fmax(i)
	fmax(i) = max{fmax(i-1)*nums[i], fmin(i-1)*nums[i], nums[i]}
优化空间：
	第i个状态只与第i-1个状态有关。
```

```c++
class Solution {
public:
    int maxProduct(vector<int>& nums) {
        int maxF = nums[0], minF = nums[0], ans = nums[0];
        for (int i = 1; i < nums.size(); ++i) {
            int mx = maxF, mn = minF;
            maxF = max(mx * nums[i], max(nums[i], mn * nums[i]));
            minF = min(mn * nums[i], min(nums[i], mx * nums[i]));
            ans = max(maxF, ans);
        }
        return ans;
    }
};
```

# 课程表

```c++
class Solution {
private:
    vector<vector<int>> edges;
    // 每个节点未遍历过的节点数量
    vector<int> indeg;
public:
    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {
        edges.resize(numCourses);
        indeg.resize(numCourses);
        for (const auto& info : prerequisites) {
            edges[info[1]].push_back(info[0]);
            ++indeg[info[0]]; // 保存每个节点的入度
        }
        queue<int> q; // 保存拓扑排序的节点
        for (int i = 0; i < numCourses; ++i) {
            // 所有入度为0的节点入队
            if (0 == indeg[i]) {
                q.push(i);
            }
        }
        int visited = 0; // 访问过的节点数量
        while (!q.empty()) {
            // 队列不空时
            ++visited;
            int u = q.front();
            q.pop();
            // 把u的所有邻接点遍历
            for (int v : edges[u]) {
                --indeg[v]; // 因为u指向v，u遍历过后，v的入度-1
                if (0 == indeg[v]) {
                    // 把u入度为0的邻接点入队
                    q.push(v);
                }
            }
        }
        return visited == numCourses;
    }
};
```

```java
class Solution {
    List<List<Integer>> edges;
    int[] visited;
    boolean valid = true;

    public boolean canFinish(int numCourses, int[][] prerequisites) {
        edges = new ArrayList<List<Integer>>();
        for (int i = 0; i < numCourses; ++i) {
            edges.add(new ArrayList<Integer>());
        }
        visited = new int[numCourses];
        for (int[] info : prerequisites) {
            edges.get(info[1]).add(info[0]);
        }
        for (int i = 0; i < numCourses && valid; ++i) {
            if (visited[i] == 0) {
                dfs(i);
            }
        }
        return valid;
    }

    public void dfs(int u) {
        visited[u] = 1;
        for (int v: edges.get(u)) {
            if (visited[v] == 0) {
                dfs(v);
                if (!valid) {
                    return;
                }
            } else if (visited[v] == 1) {
                valid = false;
                return;
            }
        }
        visited[u] = 2;
    }
}
```

# 实现Trie前缀树

树的字段：①指向子节点的指针数组children；②isEnd表示该节点是否为字符串的结尾。

```c++
class Trie {
private:
    vector<Trie*> children;
    bool isEnd;
	// 寻找匹配的前缀
    Trie* searchPrefix(string prefix) {
        // 查找当前节点有没有匹配的前缀
        Trie* node = this;
        for (char ch : prefix) {
            ch -= 'a';
            // 如果在node的子节点中不存在该字母返回空。否则把节点设为这个子节点
            if (node->children[ch] == nullptr) {
                return nullptr;
            }
            node = node->children[ch];
        }
        return node;
    }

public:
    Trie() : children(26), isEnd(false) {}

    void insert(string word) {
        Trie* node = this;
        for (char ch : word) {
            ch -= 'a';
            // 如果树中不存在该单词则插入
            if (node->children[ch] == nullptr) {
                node->children[ch] = new Trie();
            }
            node = node->children[ch];
        }
        node->isEnd = true;
    }

    bool search(string word) {
        Trie* node = this->searchPrefix(word);
        return node != nullptr && node->isEnd;
    }

    bool startsWith(string prefix) {
        return this->searchPrefix(prefix) != nullptr;
    }
};
```

# 回文链表

```java
class Solution {
    public boolean isPalindrome(ListNode head) {
        ListNode fast = head, slow = head;
        while (fast != null && fast.next != null) {
            fast = fast.next.next;
            slow = slow.next;
        }
        ListNode head2 = reverse(slow);
        while (head != null && head2 != null) {
            if (head.val != head2.val) {
                return false;
            }
            head = head.next;
            head2 = head2.next;
        }
        return true;
    }
    private ListNode reverse(ListNode head) {
        ListNode pre = null;
        while (head != null) {
            ListNode tmp = head.next;
            head.next = pre;
            pre = head;
            head = tmp;
        }
        return pre;
    }
}
```

# 二叉树的最近公共祖先

```c++
class Solution {
    TreeNode* ans;
    bool dfs(TreeNode* root, TreeNode* p, TreeNode* q) {
        if (root == nullptr) {
            return false;
        }
        bool lson = dfs(root->left, p, q);
        bool rson = dfs(root->right, p, q);
        if ((lson && rson) || ((root->val == p->val || root->val == q->val) && (lson || rson))) {
            ans = root;
        }
        return lson ||rson || (root->val == p->val || root->val == q->val);
    }
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        dfs(root, p, q);
        return ans;
    }
};
```

```java
TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
    // base case
    if (root == null) return null;
    if (root == p || root == q) return root;

    TreeNode left = lowestCommonAncestor(root.left, p, q);
    TreeNode right = lowestCommonAncestor(root.right, p, q);
    // 情况 1
    if (left != null && right != null) {
        return root;
    }
    // 情况 2
    if (left == null && right == null) {
        return null;
    }
    // 情况 3
    return left == null ? right : left;
}
```

# 除自身以外数组的乘积

描述：给定一个数组 A[0,1,…,n-1]，请构建一个数组 B[0,1,…,n-1]，其中 B[i] 的值是数组 A 中除了下标 i 以外的元素的积, 即 B[i]=A[0]×A[1]×…×A[i-1]×A[i+1]×…×A[n-1]。不能使用除法。

思路：B可以用一个矩阵来创建。定义C[i] = A[0] * ... * A[i-1], D[i] = A[i+1] * ... * A[n-1], C[i] = C[i-1] * A[i-1], D[i] = D[i+1] * A[i+1]

```c++
vector<int> constructArr(vector<int>& a) {
    int n = a.size();
    vector<int> b(n);
    if (0 == n) {
        return b;
    }
    // b[i]=a[0]*...*a[i-1]
    b[0] = 1;
    for (int i = 1; i < n; ++i) {
        b[i] = b[i - 1] * a[i - 1];
    }
    // b[i]=b[i]*tmp,tmp=a[i+1]*...*a[n-1]
    int tmp = 1;
    for (int i = n - 2; i >= 0; --i) {
        tmp *= a[i + 1];
        b[i] *= tmp;
    }
    return b;
}
```

# 滑动窗口最大值

```java
/* 单调队列的实现 */
class MonotonicQueue {
    LinkedList<Integer> q = new LinkedList<>();
    public void push(int n) {
        // 将小于 n 的元素全部删除
        while (!q.isEmpty() && q.getLast() < n) {
            q.pollLast();
        }
        // 然后将 n 加入尾部
        q.addLast(n);
    }

    public int max() {
        return q.getFirst();
    }

    public void pop(int n) {
        if (n == q.getFirst()) {
            q.pollFirst();
        }
    }
}

/* 解题函数的实现 */
int[] maxSlidingWindow(int[] nums, int k) {
    MonotonicQueue window = new MonotonicQueue();
    List<Integer> res = new ArrayList<>();

    for (int i = 0; i < nums.length; i++) {
        if (i < k - 1) {
            //先填满窗口的前 k - 1
            window.push(nums[i]);
        } else {
            // 窗口向前滑动，加入新数字
            window.push(nums[i]);
            // 记录当前窗口的最大值
            res.add(window.max());
            // 移出旧数字
            window.pop(nums[i - k + 1]);
        }
    }
    // 需要转成 int[] 数组再返回
    int[] arr = new int[res.size()];
    for (int i = 0; i < res.size(); i++) {
        arr[i] = res.get(i);
    }
    return arr;
}
```

# 会议室2

```java
class Solution {
    public int minMeetingRooms(int[][] intervals) {

    // Check for the base case. If there are no intervals, return 0
    if (intervals.length == 0) {
      return 0;
    }

    Integer[] start = new Integer[intervals.length];
    Integer[] end = new Integer[intervals.length];

    for (int i = 0; i < intervals.length; i++) {
      start[i] = intervals[i][0];
      end[i] = intervals[i][1];
    }

    // Sort the intervals by end time
    Arrays.sort(
        end,
        new Comparator<Integer>() {
          public int compare(Integer a, Integer b) {
            return a - b;
          }
        });

    // Sort the intervals by start time
    Arrays.sort(
        start,
        new Comparator<Integer>() {
          public int compare(Integer a, Integer b) {
            return a - b;
          }
        });

    // The two pointers in the algorithm: e_ptr and s_ptr.
    int startPointer = 0, endPointer = 0;

    // Variables to keep track of maximum number of rooms used.
    int usedRooms = 0;

    // Iterate over intervals.
    while (startPointer < intervals.length) {

      // If there is a meeting that has ended by the time the meeting at `start_pointer` starts
      if (start[startPointer] >= end[endPointer]) {
        usedRooms -= 1;
        endPointer += 1;
      }

      // We do this irrespective of whether a room frees up or not.
      // If a room got free, then this used_rooms += 1 wouldn't have any effect. used_rooms would
      // remain the same in that case. If no room was free, then this would increase used_rooms
      usedRooms += 1;
      startPointer += 1;

    }

    return usedRooms;
  }
}
```

# 移动0

```java
class Solution {
    public void moveZeroes(int[] nums) { 
        int n = nums.length, left = 0, right = 0;
        while (right < n) {
            if (nums[right] != 0) {
                swap(nums, left, right);
                left++;
            }
            right++;
        }
    }
    public void swap(int[] nums, int left, int right) {
        int temp = nums[left];
        nums[left] = nums[right];
        nums[right] = temp;
    }
}
```

# 完全平方数

```java
class Solution {

  public int numSquares(int n) {
    int dp[] = new int[n + 1];
    Arrays.fill(dp, Integer.MAX_VALUE);
    // bottom case
    dp[0] = 0;

    // pre-calculate the square numbers.
    int max_square_index = (int) Math.sqrt(n) + 1;
    int square_nums[] = new int[max_square_index];
    for (int i = 1; i < max_square_index; ++i) {
      square_nums[i] = i * i;
    }

    for (int i = 1; i <= n; ++i) {
      for (int s = 1; s < max_square_index; ++s) {
        if (i < square_nums[s])
          break;
        dp[i] = Math.min(dp[i], dp[i - square_nums[s]] + 1);
      }
    }
    return dp[n];
  }
}
```

